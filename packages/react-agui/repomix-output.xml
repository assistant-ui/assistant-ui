This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
scripts/
  build.mts
src/
  runtime/
    adapter/
      conversions.ts
      run-aggregator.ts
      subscriber.ts
    AGUIThreadRuntimeCore.ts
    event-parser.ts
    logger.ts
    types.ts
  index.ts
  useAGUIRuntime.ts
test/
  agui-thread-runtime-core.spec.ts
  conversions.spec.ts
  event-parser.spec.ts
  run-aggregator.spec.ts
  subscriber.spec.ts
package.json
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="scripts/build.mts">
import { Build } from "@assistant-ui/x-buildutils";

await Build.start().transpileTypescript();
</file>

<file path="src/runtime/adapter/conversions.ts">
"use client";

type ThreadMessageLike = {
  id: string;
  role: string;
  content: any;
  name?: string;
};

const generateId = () =>
  (globalThis.crypto as any)?.randomUUID?.() ??
  Math.random().toString(36).slice(2);

type AGUIToolCall = {
  id: string;
  type: "function";
  function: { name: string; arguments: string };
};

export type AGUIMessage =
  | {
      id: string;
      role: string;
      content: string;
      name?: string;
      toolCalls?: AGUIToolCall[];
    }
  | {
      id: string;
      role: "tool";
      content: string;
      toolCallId: string;
      error?: string;
    };

type ToolCallPart = {
  type: "tool-call";
  toolCallId?: string;
  toolName?: string;
  argsText?: string;
  args?: Record<string, unknown>;
  result?: unknown;
  isError?: boolean;
};

const normaliseToolCall = (part: ToolCallPart) => {
  const id = part.toolCallId ?? generateId();
  const argsText =
    typeof part.argsText === "string"
      ? part.argsText
      : JSON.stringify(part.args ?? {});
  return {
    id,
    call: {
      id,
      type: "function" as const,
      function: {
        name: part.toolName ?? "tool",
        arguments: argsText,
      },
    },
  };
};

export const toAGUIMessages = (
  messages: readonly ThreadMessageLike[],
): AGUIMessage[] => {
  const converted: AGUIMessage[] = [];

  for (const message of messages) {
    const role = message.role;
    const content = extractText(message.content);

    if (role === "assistant" && Array.isArray(message.content)) {
      const toolCallParts = message.content.filter(
        (part): part is ToolCallPart => part?.type === "tool-call",
      );

      const toolCalls = toolCallParts.map((part) => {
        const { id, call } = normaliseToolCall(part);
        return { id, call, part };
      });

      converted.push({
        id: message.id,
        role: "assistant",
        content,
        ...(message.name ? { name: message.name } : {}),
        ...(toolCalls.length > 0
          ? { toolCalls: toolCalls.map((entry) => entry.call) }
          : {}),
      });

      for (const { id: toolCallId, part } of toolCalls) {
        if (part.result === undefined) continue;

        const resultContent =
          typeof part.result === "string"
            ? part.result
            : JSON.stringify(part.result);
        converted.push({
          id: `${toolCallId}:tool`,
          role: "tool",
          content: resultContent,
          toolCallId,
          ...(part.isError ? { error: resultContent } : {}),
        });
      }

      continue;
    }

    if (role === "tool") {
      const toolCallId = (message as any).toolCallId ?? generateId();
      converted.push({
        id: message.id,
        role: "tool",
        content,
        toolCallId,
        ...(typeof (message as any).error === "string"
          ? { error: (message as any).error }
          : undefined),
      });
      continue;
    }

    converted.push({
      id: message.id,
      role,
      content,
      ...(message.name ? { name: message.name } : {}),
    });
  }

  return converted;
};

const extractText = (content: any): string => {
  if (!Array.isArray(content)) {
    if (typeof content === "string") return content;
    return "";
  }

  return content
    .filter((part) => part?.type === "text" && typeof part?.text === "string")
    .map((part) => part.text as string)
    .join("\n");
};

export const toAGUITools = (tools: Record<string, any> | undefined) => {
  if (!tools) return [];

  return Object.entries(tools)
    .filter(([, tool]) => !tool?.disabled && tool?.type !== "backend")
    .map(([name, tool]) => ({
      name,
      description: tool?.description ?? undefined,
      parameters:
        typeof tool?.parameters?.toJSON === "function"
          ? tool.parameters.toJSON()
          : typeof tool?.parameters?.toJSONSchema === "function"
            ? tool.parameters.toJSONSchema()
            : tool?.parameters,
    }));
};
</file>

<file path="src/runtime/adapter/run-aggregator.ts">
"use client";

import type {
  ChatModelRunResult,
  ThreadAssistantMessagePart,
  ToolCallMessagePart,
} from "@assistant-ui/react";
import type { AGUIEvent } from "../types";
import type { Logger } from "../logger";

type Emit = (update: ChatModelRunResult) => void;

type ToolCallState = {
  toolCallId: string;
  toolCallName: string;
  argsText: string;
  parsedArgs: Record<string, unknown> | undefined;
  result: unknown;
  isError: boolean | undefined;
  parentMessageId?: string;
};

export type RunAggregatorOptions = {
  showThinking: boolean;
  logger: Logger;
  emit: Emit;
};

/**
 * Collects AG-UI events into assistant-ui run snapshots that can be yielded from a ChatModelAdapter.
 *
 * The aggregator keeps a single assistant message worth of parts. Each incoming event updates the parts and
 * emits a fresh snapshot through the provided `emit` callback.
 */
export class RunAggregator {
  private readonly emitUpdate: Emit;
  private readonly showThinking: boolean;
  private readonly logger: Logger;

  private status: ChatModelRunResult["status"] | undefined;
  private readonly textParts = new Map<
    string,
    { buffer: string; touched: boolean }
  >();
  private activeTextMessageId: string | undefined;
  private reasoningBuffer = "";
  private reasoningActive = false;
  private readonly toolCalls = new Map<string, ToolCallState>();
  private readonly partOrder: (
    | { kind: "text"; key: string }
    | { kind: "reasoning" }
    | { kind: "tool-call"; toolCallId: string }
  )[] = [];
  private hasReasoningPart = false;
  private textPartCounter = 0;

  constructor(options: RunAggregatorOptions) {
    this.emitUpdate = options.emit;
    this.showThinking = options.showThinking;
    this.logger = options.logger;
  }

  handle(event: AGUIEvent): void {
    switch (event.type) {
      case "RUN_STARTED": {
        this.clearTextParts();
        this.reasoningBuffer = "";
        this.reasoningActive = false;
        this.toolCalls.clear();
        this.partOrder.length = 0;
        this.hasReasoningPart = false;
        this.textPartCounter = 0;
        this.activeTextMessageId = undefined;
        this.status = { type: "running" };
        this.emit();
        break;
      }
      case "RUN_FINISHED": {
        this.status = { type: "complete", reason: "unknown" };
        this.emit();
        break;
      }
      case "RUN_ERROR": {
        this.status = {
          type: "incomplete",
          reason: "error",
          ...(event.message !== undefined ? { error: event.message } : {}),
        };
        this.emit();
        break;
      }
      case "RUN_CANCELLED": {
        this.status = { type: "incomplete", reason: "cancelled" };
        this.emit();
        break;
      }

      case "TEXT_MESSAGE_START": {
        const id = this.startTextMessage(event.messageId);
        if (id) {
          this.markTextPartTouched(id);
        }
        this.emit();
        break;
      }
      case "TEXT_MESSAGE_CONTENT":
      case "TEXT_MESSAGE_CHUNK": {
        if (!event.delta) break;
        const id = this.resolveTextMessageId(
          "messageId" in event ? event.messageId : undefined,
        );
        this.appendText(id, event.delta);
        this.emit();
        break;
      }
      case "TEXT_MESSAGE_END": {
        if (event.messageId && this.activeTextMessageId === event.messageId) {
          this.activeTextMessageId = undefined;
        }
        this.emit();
        break;
      }

      case "THINKING_START":
      case "THINKING_TEXT_MESSAGE_START": {
        if (!this.showThinking) break;
        this.reasoningActive = true;
        if (!this.reasoningBuffer) this.reasoningBuffer = "";
        this.ensureReasoningPart();
        this.emit();
        break;
      }
      case "THINKING_TEXT_MESSAGE_CONTENT": {
        if (!this.showThinking || !event.delta) break;
        this.reasoningBuffer += event.delta;
        this.ensureReasoningPart();
        this.emit();
        break;
      }
      case "THINKING_TEXT_MESSAGE_END":
      case "THINKING_END": {
        if (!this.showThinking) break;
        this.emit();
        break;
      }

      case "TOOL_CALL_START": {
        this.startToolCall(
          event.toolCallId,
          event.toolCallName,
          event.parentMessageId,
        );
        this.emit();
        break;
      }
      case "TOOL_CALL_ARGS":
      case "TOOL_CALL_CHUNK": {
        if (!event.delta) break;
        this.appendToolArgs(event.toolCallId, event.delta);
        this.emit();
        break;
      }
      case "TOOL_CALL_END": {
        this.emit();
        break;
      }
      case "TOOL_CALL_RESULT": {
        this.finishToolCall(
          event.toolCallId,
          event.content ?? "",
          event.role === "tool" ? false : undefined,
        );
        this.emit();
        break;
      }

      default: {
        this.logger.debug?.("[agui] aggregator ignored event", event);
      }
    }
  }

  private clearTextParts(): void {
    this.textParts.clear();
  }

  private generateTextKey(): string {
    this.textPartCounter += 1;
    return `text-${this.textPartCounter}`;
  }

  private startTextMessage(messageId?: string): string {
    const id = messageId ?? this.generateTextKey();
    this.ensureTextPart(id);
    this.activeTextMessageId = id;
    return id;
  }

  private resolveTextMessageId(messageId?: string): string {
    if (messageId) {
      this.ensureTextPart(messageId);
      this.activeTextMessageId = messageId;
      return messageId;
    }

    if (this.activeTextMessageId) {
      return this.activeTextMessageId;
    }

    const generated = this.generateTextKey();
    this.ensureTextPart(generated);
    this.activeTextMessageId = generated;
    return generated;
  }

  private ensureTextPart(id: string): void {
    if (!this.textParts.has(id)) {
      this.textParts.set(id, { buffer: "", touched: false });
      if (
        !this.partOrder.some((part) => part.kind === "text" && part.key === id)
      ) {
        this.partOrder.push({ kind: "text", key: id });
      }
    }
  }

  private markTextPartTouched(id: string): void {
    const entry = this.textParts.get(id);
    if (!entry) return;
    entry.touched = true;
  }

  private appendText(id: string, delta: string): void {
    this.ensureTextPart(id);
    const entry = this.textParts.get(id);
    if (!entry) return;
    entry.buffer += delta;
    entry.touched = true;
  }

  private startToolCall(
    id: string | undefined,
    name?: string,
    parentMessageId?: string,
  ) {
    if (!id) return;
    if (
      !this.partOrder.some(
        (part) => part.kind === "tool-call" && part.toolCallId === id,
      )
    ) {
      this.partOrder.push({ kind: "tool-call", toolCallId: id });
    }
    const state: ToolCallState = {
      toolCallId: id,
      toolCallName: name ?? "tool",
      argsText: "",
      parsedArgs: undefined,
      result: undefined,
      isError: undefined,
    };
    if (parentMessageId) {
      state.parentMessageId = parentMessageId;
    }
    this.toolCalls.set(id, state);
  }

  private appendToolArgs(id: string | undefined, delta: string) {
    const entry = id ? this.toolCalls.get(id) : undefined;
    if (!entry) return;
    entry.argsText += delta;
    try {
      const parsed = JSON.parse(entry.argsText);
      if (parsed && typeof parsed === "object") {
        entry.parsedArgs = parsed as Record<string, unknown>;
      } else {
        entry.parsedArgs = undefined;
      }
    } catch {
      entry.parsedArgs = undefined;
    }
  }

  private finishToolCall(id: string, content: string, isError?: boolean) {
    if (!id) return;
    let entry = this.toolCalls.get(id);
    if (!entry) {
      entry = {
        toolCallId: id,
        toolCallName: "tool",
        argsText: "",
        parsedArgs: undefined,
        result: undefined,
        isError: undefined,
      };
      this.toolCalls.set(id, entry);
    }
    if (
      !this.partOrder.some(
        (part) => part.kind === "tool-call" && part.toolCallId === id,
      )
    ) {
      this.partOrder.push({ kind: "tool-call", toolCallId: id });
    }
    entry.result = this.tryParseJSON(content);
    entry.isError = isError;
  }

  private tryParseJSON(value: string): unknown {
    if (!value) return value;
    try {
      return JSON.parse(value);
    } catch {
      return value;
    }
  }

  private emit(): void {
    const snapshot: ThreadAssistantMessagePart[] = [];

    for (const part of this.partOrder) {
      if (part.kind === "reasoning") {
        if (
          this.showThinking &&
          (this.reasoningActive || this.reasoningBuffer.length > 0)
        ) {
          snapshot.push({
            type: "reasoning",
            text: this.reasoningBuffer,
          } as const);
        }
        continue;
      }

      if (part.kind === "text") {
        const entry = this.textParts.get(part.key);
        if (entry?.touched) {
          snapshot.push({ type: "text", text: entry.buffer } as const);
        }
        continue;
      }

      const entry = this.toolCalls.get(part.toolCallId);
      if (!entry) continue;
      const toolPart: ToolCallMessagePart = {
        type: "tool-call",
        toolCallId: entry.toolCallId,
        toolName: entry.toolCallName,
        args: (entry.parsedArgs ?? {}) as any,
        argsText: entry.argsText,
        ...(entry.result !== undefined ? { result: entry.result } : {}),
        ...(entry.isError !== undefined ? { isError: entry.isError } : {}),
        ...(entry.parentMessageId ? { parentId: entry.parentMessageId } : {}),
      } as ToolCallMessagePart;
      snapshot.push(toolPart);
    }

    const result: ChatModelRunResult = {
      content: snapshot,
      ...(this.status ? { status: this.status } : undefined),
    };
    this.emitUpdate(result);
  }

  private ensureReasoningPart(): void {
    if (this.hasReasoningPart) return;
    // ensure reasoning appears before the first text segment if possible
    const textIndex = this.partOrder.findIndex((part) => part.kind === "text");
    if (textIndex === -1) {
      this.partOrder.push({ kind: "reasoning" });
    } else {
      this.partOrder.splice(textIndex, 0, { kind: "reasoning" });
    }
    this.hasReasoningPart = true;
  }
}
</file>

<file path="src/runtime/adapter/subscriber.ts">
"use client";

import type { AGUIEvent } from "../types";
import { parseAGUIEvent } from "../event-parser";

type Dispatch = (event: AGUIEvent) => void;

type Subscriber = {
  onEvent?: (payload: { event: unknown }) => void;
  onTextMessageStartEvent?: (payload: { event: unknown }) => void;
  onTextMessageContentEvent?: (payload: { event: unknown }) => void;
  onTextMessageEndEvent?: (payload: { event: unknown }) => void;
  onTextMessageChunkEvent?: (payload: { event: unknown }) => void;
  onThinkingStartEvent?: (payload: { event: unknown }) => void;
  onThinkingEndEvent?: (payload: { event: unknown }) => void;
  onThinkingTextMessageStartEvent?: (payload: { event: unknown }) => void;
  onThinkingTextMessageContentEvent?: (payload: { event: unknown }) => void;
  onThinkingTextMessageEndEvent?: (payload: { event: unknown }) => void;
  onToolCallStartEvent?: (payload: { event: unknown }) => void;
  onToolCallArgsEvent?: (payload: { event: unknown }) => void;
  onToolCallEndEvent?: (payload: { event: unknown }) => void;
  onToolCallChunkEvent?: (payload: { event: unknown }) => void;
  onToolCallResultEvent?: (payload: { event: unknown }) => void;
  onStateSnapshotEvent?: (payload: { event: unknown }) => void;
  onStateDeltaEvent?: (payload: { event: unknown }) => void;
  onMessagesSnapshotEvent?: (payload: { event: unknown }) => void;
  onCustomEvent?: (payload: { event: unknown }) => void;
  onRawEvent?: (payload: { event: unknown }) => void;
  onRunFinalized?: () => void;
  onRunFailed?: (payload: { error: Error }) => void;
};

const ensureEvent = (
  raw: unknown,
  type: AGUIEvent["type"],
): AGUIEvent | null => {
  if (raw && typeof raw === "object") {
    const payload = raw as Record<string, unknown>;
    if (typeof payload["type"] === "string") {
      return parseAGUIEvent(payload);
    }
    return parseAGUIEvent({ type, ...payload });
  }
  return parseAGUIEvent({ type });
};

const dispatchIfValid = (
  dispatch: Dispatch,
  raw: unknown,
  type: AGUIEvent["type"],
) => {
  const event = ensureEvent(raw, type);
  if (!event) return;
  dispatch(event);
};

type SubscriberOptions = {
  dispatch: Dispatch;
  runId: string;
  onRunFailed?: (error: Error) => void;
};

export const createAGUISubscriber = (
  options: SubscriberOptions,
): Subscriber => {
  const { dispatch, runId, onRunFailed } = options;
  return {
    onEvent: ({ event }) => {
      const typeCandidate =
        event && typeof event === "object"
          ? (event as Record<string, unknown>)["type"]
          : undefined;
      if (typeof typeCandidate === "string") {
        // Typed handlers will receive this via the discriminated callbacks; avoid duplicates.
        return;
      }
      const parsed = parseAGUIEvent(event);
      if (parsed) dispatch(parsed);
    },
    onTextMessageStartEvent: ({ event }) =>
      dispatchIfValid(dispatch, event, "TEXT_MESSAGE_START"),
    onTextMessageContentEvent: ({ event }) =>
      dispatchIfValid(dispatch, event, "TEXT_MESSAGE_CONTENT"),
    onTextMessageEndEvent: ({ event }) =>
      dispatchIfValid(dispatch, event, "TEXT_MESSAGE_END"),
    onTextMessageChunkEvent: ({ event }) =>
      dispatchIfValid(dispatch, event, "TEXT_MESSAGE_CHUNK"),
    onThinkingStartEvent: ({ event }) =>
      dispatchIfValid(dispatch, event, "THINKING_START"),
    onThinkingEndEvent: ({ event }) =>
      dispatchIfValid(dispatch, event, "THINKING_END"),
    onThinkingTextMessageStartEvent: ({ event }) =>
      dispatchIfValid(dispatch, event, "THINKING_TEXT_MESSAGE_START"),
    onThinkingTextMessageContentEvent: ({ event }) =>
      dispatchIfValid(dispatch, event, "THINKING_TEXT_MESSAGE_CONTENT"),
    onThinkingTextMessageEndEvent: ({ event }) =>
      dispatchIfValid(dispatch, event, "THINKING_TEXT_MESSAGE_END"),
    onToolCallStartEvent: ({ event }) =>
      dispatchIfValid(dispatch, event, "TOOL_CALL_START"),
    onToolCallArgsEvent: ({ event }) =>
      dispatchIfValid(dispatch, event, "TOOL_CALL_ARGS"),
    onToolCallEndEvent: ({ event }) =>
      dispatchIfValid(dispatch, event, "TOOL_CALL_END"),
    onToolCallChunkEvent: ({ event }) =>
      dispatchIfValid(dispatch, event, "TOOL_CALL_CHUNK"),
    onToolCallResultEvent: ({ event }) =>
      dispatchIfValid(dispatch, event, "TOOL_CALL_RESULT"),
    onStateSnapshotEvent: ({ event }) =>
      dispatchIfValid(dispatch, event, "STATE_SNAPSHOT"),
    onStateDeltaEvent: ({ event }) =>
      dispatchIfValid(dispatch, event, "STATE_DELTA"),
    onMessagesSnapshotEvent: ({ event }) =>
      dispatchIfValid(dispatch, event, "MESSAGES_SNAPSHOT"),
    onCustomEvent: ({ event }) => dispatchIfValid(dispatch, event, "CUSTOM"),
    onRawEvent: ({ event }) => dispatchIfValid(dispatch, event, "RAW"),
    onRunFinalized: () => dispatch({ type: "RUN_FINISHED", runId }),
    onRunFailed: ({ error }) => {
      onRunFailed?.(error);
      const message =
        typeof error.message === "string" ? error.message : "Run failed";
      const code =
        typeof (error as any)?.code === "string"
          ? (error as any).code
          : undefined;
      dispatch({
        type: "RUN_ERROR" as const,
        ...(message !== undefined ? { message } : {}),
        ...(code !== undefined ? { code } : {}),
      } satisfies AGUIEvent);
    },
  };
};

export type AGUISubscriber = ReturnType<typeof createAGUISubscriber>;
</file>

<file path="src/runtime/AGUIThreadRuntimeCore.ts">
"use client";

import { INTERNAL } from "@assistant-ui/react";
import type {
  AddToolResultOptions,
  AppendMessage,
  AssistantRuntime,
  ChatModelRunResult,
  MessageStatus,
  ThreadAssistantMessage,
  ThreadHistoryAdapter,
  ThreadMessage,
} from "@assistant-ui/react";
import type { HttpAgent } from "@ag-ui/client";
import type { Logger } from "./logger";
import type { AGUIEvent } from "./types";
import type { ReadonlyJSONValue } from "assistant-stream/utils";
import { RunAggregator } from "./adapter/run-aggregator";
import { toAGUIMessages, toAGUITools } from "./adapter/conversions";
import { createAGUISubscriber } from "./adapter/subscriber";

type RunConfig = NonNullable<AppendMessage["runConfig"]>;
type ResumeRunConfig = {
  parentId: string | null;
  sourceId: string | null;
  runConfig: RunConfig;
  stream?: unknown;
};

type CoreOptions = {
  agent: HttpAgent;
  logger: Logger;
  showThinking: boolean;
  onError?: (error: Error) => void;
  onCancel?: () => void;
  history?: ThreadHistoryAdapter;
  notifyUpdate: () => void;
};

const FALLBACK_USER_STATUS = { type: "complete", reason: "unknown" } as const;

export class AGUIThreadRuntimeCore {
  private agent: HttpAgent;
  private logger: Logger;
  private showThinking: boolean;
  private onError: ((error: Error) => void) | undefined;
  private onCancel: (() => void) | undefined;
  private readonly notifyUpdate: () => void;

  private runtime: AssistantRuntime | undefined;
  private messages: ThreadMessage[] = [];
  private isRunningFlag = false;
  private abortController: AbortController | null = null;
  private stateSnapshot: ReadonlyJSONValue | undefined;
  private pendingError: Error | null = null;
  private history: ThreadHistoryAdapter | undefined;
  private lastRunConfig: RunConfig | undefined;
  private readonly assistantHistoryParents = new Map<string, string | null>();
  private readonly recordedHistoryIds = new Set<string>();

  constructor(options: CoreOptions) {
    this.agent = options.agent;
    this.logger = options.logger;
    this.showThinking = options.showThinking;
    this.onError = options.onError;
    this.onCancel = options.onCancel;
    this.history = options.history;
    this.notifyUpdate = options.notifyUpdate;
  }

  updateOptions(options: Omit<CoreOptions, "notifyUpdate">) {
    this.agent = options.agent;
    this.logger = options.logger;
    this.showThinking = options.showThinking;
    this.onError = options.onError;
    this.onCancel = options.onCancel;
    this.history = options.history;
  }

  attachRuntime(runtime: AssistantRuntime) {
    this.runtime = runtime;
  }

  detachRuntime() {
    this.runtime = undefined;
  }

  getMessages(): readonly ThreadMessage[] {
    return this.messages;
  }

  getState(): ReadonlyJSONValue | undefined {
    return this.stateSnapshot;
  }

  isRunning(): boolean {
    return this.isRunningFlag;
  }

  async append(message: AppendMessage): Promise<void> {
    const startRun = message.startRun ?? message.role === "user";
    if (message.sourceId) {
      this.messages = this.messages.filter(
        (entry) => entry.id !== message.sourceId,
      );
    }
    this.resetHead(message.parentId);

    const threadMessage = this.toThreadMessage(message);
    this.messages = [...this.messages, threadMessage];
    this.notifyUpdate();
    this.recordHistoryEntry(message.parentId ?? null, threadMessage);

    if (!startRun) return;
    await this.startRun(threadMessage.id, message.runConfig);
  }

  async edit(message: AppendMessage): Promise<void> {
    await this.append(message);
  }

  async reload(
    parentId: string | null,
    config: { runConfig?: RunConfig } = {},
  ): Promise<void> {
    this.resetHead(parentId);
    this.notifyUpdate();
    await this.startRun(parentId, config.runConfig);
  }

  async cancel(): Promise<void> {
    if (!this.abortController) return;
    this.abortController.abort();
  }

  async resume(config: ResumeRunConfig): Promise<void> {
    if (config.stream) {
      this.logger.debug?.(
        "[agui] resume stream is not supported, falling back to regular run",
      );
    }
    await this.startRun(
      config.parentId,
      config.runConfig ?? this.lastRunConfig,
    );
  }

  addToolResult(options: AddToolResultOptions): void {
    let updated = false;
    this.messages = this.messages.map((message) => {
      if (message.id !== options.messageId || message.role !== "assistant")
        return message;
      updated = true;
      const assistant = message as ThreadAssistantMessage;
      const content = assistant.content.map((part) => {
        if (part.type !== "tool-call" || part.toolCallId !== options.toolCallId)
          return part;
        return {
          ...part,
          result: options.result,
          artifact: options.artifact,
          isError: options.isError,
        };
      });
      return {
        ...assistant,
        content,
      };
    });

    if (updated) {
      this.notifyUpdate();
    }
  }

  applyExternalMessages(messages: readonly ThreadMessage[]): void {
    this.assistantHistoryParents.clear();
    this.messages = [...messages];
    this.recordedHistoryIds.clear();
    for (const message of this.messages) {
      this.recordedHistoryIds.add(message.id);
    }
    this.notifyUpdate();
  }

  loadExternalState(state: ReadonlyJSONValue): void {
    this.stateSnapshot = state;
    this.notifyUpdate();
  }

  private async startRun(
    parentId: string | null,
    runConfig?: RunConfig,
  ): Promise<void> {
    const normalizedRunConfig = runConfig ?? {};
    this.lastRunConfig = normalizedRunConfig;
    this.resetHead(parentId);
    const historicalMessages = [...this.messages];

    const runId = INTERNAL.generateId();
    this.pendingError = null;
    const input = this.buildRunInput(
      runId,
      normalizedRunConfig,
      historicalMessages,
    );
    const assistantParentId = parentId ?? this.messages.at(-1)?.id ?? null;
    let assistantMessageId: string | undefined;
    const ensureAssistant = () => {
      if (assistantMessageId) return assistantMessageId;
      const created = this.insertAssistantPlaceholder();
      assistantMessageId = created;
      this.markPendingAssistantHistory(created, assistantParentId ?? null);
      return created;
    };

    const aggregator = new RunAggregator({
      showThinking: this.showThinking,
      logger: this.logger,
      emit: (update) => this.updateAssistantMessage(ensureAssistant(), update),
    });
    const dispatch = (event: AGUIEvent) => this.handleEvent(aggregator, event);

    const abortController = new AbortController();
    const abortSignal = abortController.signal;
    this.abortController = abortController;

    abortSignal.addEventListener(
      "abort",
      () => {
        dispatch({ type: "RUN_CANCELLED" });
        this.finishRun(abortController);
        this.onCancel?.();
      },
      { once: true },
    );

    const subscriber = createAGUISubscriber({
      dispatch,
      runId,
      onRunFailed: (error) => {
        this.pendingError = error;
        this.onError?.(error);
      },
    });

    aggregator.handle({ type: "RUN_STARTED", runId });
    this.setRunning(true);

    try {
      try {
        (this.agent as any).messages = input.messages;
        (this.agent as any).threadId = input.threadId;
      } catch {
        // ignore
      }
      await (this.agent as any).runAgent(input, subscriber, {
        signal: abortSignal,
      });
    } catch (error) {
      if (!abortSignal.aborted) {
        const err = error instanceof Error ? error : new Error(String(error));
        dispatch({ type: "RUN_ERROR", message: err.message });
        this.onError?.(err);
        this.pendingError = this.pendingError ?? err;
      }
    } finally {
      this.finishRun(abortController);
    }

    if (this.pendingError) {
      const err = this.pendingError;
      this.pendingError = null;
      throw err;
    }
  }

  private buildRunInput(
    runId: string,
    runConfig: RunConfig | undefined,
    historyMessages: readonly ThreadMessage[] | undefined,
  ) {
    const threadId = "main";
    const messages = toAGUIMessages(historyMessages ?? this.messages);
    const context = this.runtime?.thread.getModelContext();
    return {
      threadId,
      runId,
      state: this.stateSnapshot ?? null,
      messages,
      tools: toAGUITools(context?.tools),
      context: context?.system
        ? [{ description: "system", value: context.system }]
        : [],
      forwardedProps: {
        ...(context?.callSettings ?? {}),
        ...(context?.config ?? {}),
        ...(runConfig?.custom ? { runConfig: runConfig.custom } : {}),
      },
    };
  }

  private setRunning(running: boolean) {
    this.isRunningFlag = running;
    this.notifyUpdate();
  }

  private finishRun(controller: AbortController | null) {
    if (this.abortController === controller) {
      this.abortController = null;
    }
    this.setRunning(false);
  }

  private insertAssistantPlaceholder(): string {
    const id = INTERNAL.generateId();
    const assistant: ThreadAssistantMessage = {
      id,
      role: "assistant",
      createdAt: new Date(),
      status: { type: "running" },
      content: [],
      metadata: {
        unstable_state: this.stateSnapshot ?? null,
        unstable_annotations: [],
        unstable_data: [],
        steps: [],
        custom: {},
      },
    };
    this.messages = [...this.messages, assistant];
    this.notifyUpdate();
    return id;
  }

  private updateAssistantMessage(
    messageId: string,
    update: ChatModelRunResult,
  ) {
    let touched = false;
    let latestStatus: MessageStatus | undefined;
    this.messages = this.messages.map((message) => {
      if (message.id !== messageId || message.role !== "assistant")
        return message;
      touched = true;
      const assistant = message as ThreadAssistantMessage;
      const metadata = update.metadata
        ? this.mergeAssistantMetadata(assistant.metadata, update.metadata)
        : assistant.metadata;
      latestStatus = update.status ?? assistant.status;
      return {
        ...assistant,
        content: (update.content ??
          assistant.content) as ThreadAssistantMessage["content"],
        status: latestStatus,
        metadata,
      };
    });
    if (touched) {
      this.notifyUpdate();
      if (this.isTerminalStatus(latestStatus)) {
        this.persistAssistantHistory(messageId);
      }
    }
  }

  private mergeAssistantMetadata(
    current: ThreadAssistantMessage["metadata"],
    incoming: NonNullable<ChatModelRunResult["metadata"]>,
  ): ThreadAssistantMessage["metadata"] {
    const annotations = incoming.unstable_annotations
      ? [...current.unstable_annotations, ...incoming.unstable_annotations]
      : current.unstable_annotations;
    const data = incoming.unstable_data
      ? [...current.unstable_data, ...incoming.unstable_data]
      : current.unstable_data;
    const steps = incoming.steps
      ? [...current.steps, ...incoming.steps]
      : current.steps;
    return {
      unstable_state:
        incoming.unstable_state !== undefined
          ? incoming.unstable_state
          : current.unstable_state,
      unstable_annotations: annotations,
      unstable_data: data,
      steps,
      custom: incoming.custom
        ? { ...current.custom, ...incoming.custom }
        : current.custom,
    };
  }

  private handleEvent(aggregator: RunAggregator, event: AGUIEvent) {
    switch (event.type) {
      case "STATE_SNAPSHOT": {
        this.stateSnapshot = event.snapshot as ReadonlyJSONValue;
        this.notifyUpdate();
        return;
      }
      case "STATE_DELTA": {
        this.logger.debug?.("[agui] state delta event ignored", event.delta);
        return;
      }
      case "MESSAGES_SNAPSHOT": {
        this.importMessagesSnapshot(event.messages);
        return;
      }
      default:
        aggregator.handle(event);
    }
  }

  private importMessagesSnapshot(rawMessages: readonly unknown[]) {
    try {
      const converted = rawMessages.map((message) =>
        INTERNAL.fromThreadMessageLike(
          message as any,
          INTERNAL.generateId(),
          FALLBACK_USER_STATUS,
        ),
      );
      this.applyExternalMessages(converted);
    } catch (error) {
      this.logger.error?.("[agui] failed to import messages snapshot", error);
    }
  }

  private toThreadMessage(message: AppendMessage): ThreadMessage {
    return INTERNAL.fromThreadMessageLike(
      message as any,
      INTERNAL.generateId(),
      FALLBACK_USER_STATUS,
    );
  }

  private resetHead(parentId: string | null | undefined) {
    if (!parentId) {
      if (this.messages.length) {
        this.messages = [];
      }
      return;
    }
    const idx = this.messages.findIndex((message) => message.id === parentId);
    if (idx === -1) return;
    this.messages = this.messages.slice(0, idx + 1);
  }

  private isTerminalStatus(status?: MessageStatus): boolean {
    return status?.type === "complete" || status?.type === "incomplete";
  }

  private recordHistoryEntry(parentId: string | null, message: ThreadMessage) {
    this.appendHistoryItem(parentId, message);
  }

  private markPendingAssistantHistory(
    messageId: string,
    parentId: string | null,
  ) {
    if (!this.history) return;
    this.assistantHistoryParents.set(messageId, parentId);
  }

  private persistAssistantHistory(messageId: string) {
    if (!this.history) return;
    const parentId = this.assistantHistoryParents.get(messageId);
    if (parentId === undefined) return;
    const message = this.messages.find((m) => m.id === messageId);
    if (!message || message.role !== "assistant") return;
    if (!this.isTerminalStatus(message.status)) return;
    this.assistantHistoryParents.delete(messageId);
    this.appendHistoryItem(parentId, message);
  }

  private appendHistoryItem(parentId: string | null, message: ThreadMessage) {
    if (!this.history || this.recordedHistoryIds.has(message.id)) return;
    this.recordedHistoryIds.add(message.id);
    void this.history.append({ parentId, message }).catch((error) => {
      this.recordedHistoryIds.delete(message.id);
      this.logger.error?.("[agui] failed to append history entry", error);
    });
  }
}
</file>

<file path="src/runtime/event-parser.ts">
import type { AGUIEvent } from "./types";

const isString = (value: unknown): value is string => typeof value === "string";
const isNonEmptyString = (value: unknown): value is string =>
  isString(value) && value.length > 0;

const withOptional = <T extends object>(
  base: T,
  optionals: Record<string, unknown>,
) => {
  const definedEntries = Object.entries(optionals).filter(
    ([, value]) => value !== undefined,
  );
  return definedEntries.length === 0
    ? base
    : ({ ...base, ...Object.fromEntries(definedEntries) } as T);
};

export const parseAGUIEvent = (event: unknown): AGUIEvent | null => {
  if (!event || typeof event !== "object") return null;
  const payload = event as Record<string, unknown>;
  const typeValue = payload["type"];
  if (!isString(typeValue)) return null;

  const getString = (key: string) =>
    isString(payload[key]) ? (payload[key] as string) : undefined;

  switch (typeValue) {
    case "RUN_STARTED": {
      const runId = getString("runId");
      return runId ? { type: "RUN_STARTED", runId } : null;
    }
    case "RUN_FINISHED": {
      const runId = getString("runId");
      return runId ? { type: "RUN_FINISHED", runId } : null;
    }
    case "RUN_CANCELLED": {
      const runId = getString("runId");
      return withOptional({ type: "RUN_CANCELLED" as const }, { runId });
    }
    case "RUN_ERROR": {
      return withOptional(
        { type: "RUN_ERROR" as const },
        {
          message: getString("message"),
          code: getString("code"),
        },
      );
    }
    case "TEXT_MESSAGE_START":
      return withOptional(
        { type: "TEXT_MESSAGE_START" as const },
        { messageId: getString("messageId") },
      );
    case "TEXT_MESSAGE_CONTENT": {
      const delta = getString("delta");
      if (!isNonEmptyString(delta)) return null;
      return withOptional(
        { type: "TEXT_MESSAGE_CONTENT" as const, delta },
        { messageId: getString("messageId") },
      );
    }
    case "TEXT_MESSAGE_END":
      return withOptional(
        { type: "TEXT_MESSAGE_END" as const },
        { messageId: getString("messageId") },
      );
    case "TEXT_MESSAGE_CHUNK": {
      const delta = getString("delta") ?? "";
      return withOptional(
        { type: "TEXT_MESSAGE_CHUNK" as const, delta },
        { messageId: getString("messageId") },
      );
    }
    case "THINKING_START":
      return withOptional(
        { type: "THINKING_START" as const },
        { title: getString("title") },
      );
    case "THINKING_TEXT_MESSAGE_START":
      return { type: "THINKING_TEXT_MESSAGE_START" };
    case "THINKING_TEXT_MESSAGE_CONTENT": {
      const delta = getString("delta") ?? "";
      return { type: "THINKING_TEXT_MESSAGE_CONTENT", delta };
    }
    case "THINKING_TEXT_MESSAGE_END":
      return { type: "THINKING_TEXT_MESSAGE_END" };
    case "THINKING_END":
      return { type: "THINKING_END" };
    case "TOOL_CALL_START": {
      const toolCallId = getString("toolCallId");
      if (!toolCallId) return null;
      return withOptional(
        { type: "TOOL_CALL_START" as const, toolCallId },
        {
          toolCallName: getString("toolCallName"),
          parentMessageId: getString("parentMessageId"),
        },
      );
    }
    case "TOOL_CALL_ARGS": {
      const toolCallId = getString("toolCallId");
      if (!toolCallId) return null;
      const delta = getString("delta") ?? "";
      return { type: "TOOL_CALL_ARGS", toolCallId, delta };
    }
    case "TOOL_CALL_END": {
      const toolCallId = getString("toolCallId");
      return toolCallId ? { type: "TOOL_CALL_END", toolCallId } : null;
    }
    case "TOOL_CALL_CHUNK":
      return withOptional(
        { type: "TOOL_CALL_CHUNK" as const },
        {
          toolCallId: getString("toolCallId"),
          toolCallName: getString("toolCallName"),
          parentMessageId: getString("parentMessageId"),
          delta: getString("delta"),
        },
      );
    case "TOOL_CALL_RESULT": {
      const toolCallId = getString("toolCallId");
      if (!toolCallId) return null;
      return withOptional(
        {
          type: "TOOL_CALL_RESULT" as const,
          toolCallId,
          content: getString("content") ?? "",
        },
        {
          messageId: getString("messageId"),
          role: payload["role"] === "tool" ? "tool" : undefined,
        },
      );
    }
    case "STATE_SNAPSHOT":
      return { type: "STATE_SNAPSHOT", snapshot: payload["snapshot"] };
    case "STATE_DELTA":
      return {
        type: "STATE_DELTA",
        delta: Array.isArray(payload["delta"])
          ? (payload["delta"] as any[])
          : [],
      };
    case "MESSAGES_SNAPSHOT":
      return {
        type: "MESSAGES_SNAPSHOT",
        messages: Array.isArray(payload["messages"])
          ? (payload["messages"] as any[])
          : [],
      };
    case "RAW":
      return withOptional(
        { type: "RAW" as const, event: payload["event"] },
        { source: getString("source") },
      );
    case "CUSTOM": {
      const name = getString("name");
      if (!name) return null;
      return { type: "CUSTOM", name, value: payload["value"] };
    }
    default:
      return withOptional(
        { type: "RAW" as const, event: payload },
        {
          source: isString(payload["type"])
            ? (payload["type"] as string)
            : undefined,
        },
      );
  }
};
</file>

<file path="src/runtime/logger.ts">
export type Logger = {
  debug: (...a: any[]) => void;
  error: (...a: any[]) => void;
};

export const makeLogger = (l?: Partial<Logger>): Logger => ({
  debug: (...a) => l?.debug?.(...a),
  error: (...a) => l?.error?.(...a),
});
</file>

<file path="src/runtime/types.ts">
import type {
  AttachmentAdapter,
  FeedbackAdapter,
  SpeechSynthesisAdapter,
  ThreadHistoryAdapter,
} from "@assistant-ui/react";
import type { HttpAgent } from "@ag-ui/client";
import type { Logger } from "./logger";

export type UseAGUIRuntimeAdapters = {
  attachments?: AttachmentAdapter;
  speech?: SpeechSynthesisAdapter;
  feedback?: FeedbackAdapter;
  history?: ThreadHistoryAdapter;
};

export type UseAGUIRuntimeOptions = {
  agent: HttpAgent;
  logger?: Partial<Logger>;
  showThinking?: boolean;
  onError?: (e: Error) => void;
  onCancel?: () => void;
  adapters?: UseAGUIRuntimeAdapters;
};

export type AGUIEvent =
  | { type: "RUN_STARTED"; runId: string }
  | { type: "RUN_FINISHED"; runId: string }
  | { type: "RUN_CANCELLED"; runId?: string }
  | { type: "RUN_ERROR"; message?: string; code?: string }
  | { type: "TEXT_MESSAGE_START"; messageId?: string }
  | { type: "TEXT_MESSAGE_CONTENT"; messageId?: string; delta: string }
  | { type: "TEXT_MESSAGE_END"; messageId?: string }
  | { type: "TEXT_MESSAGE_CHUNK"; delta: string }
  | { type: "THINKING_START"; title?: string }
  | { type: "THINKING_TEXT_MESSAGE_START" }
  | { type: "THINKING_TEXT_MESSAGE_CONTENT"; delta: string }
  | { type: "THINKING_TEXT_MESSAGE_END" }
  | { type: "THINKING_END" }
  | {
      type: "TOOL_CALL_START";
      toolCallId: string;
      toolCallName?: string;
      parentMessageId?: string;
    }
  | { type: "TOOL_CALL_ARGS"; toolCallId: string; delta: string }
  | { type: "TOOL_CALL_END"; toolCallId: string }
  | {
      type: "TOOL_CALL_CHUNK";
      toolCallId?: string;
      toolCallName?: string;
      parentMessageId?: string;
      delta?: string;
    }
  | {
      type: "TOOL_CALL_RESULT";
      messageId?: string;
      toolCallId: string;
      content: string;
      role?: "tool";
    }
  | { type: "RAW"; event: any; source?: string }
  | { type: "CUSTOM"; name: string; value: any }
  | { type: "STATE_SNAPSHOT"; snapshot: any }
  | { type: "STATE_DELTA"; delta: any[] }
  | { type: "MESSAGES_SNAPSHOT"; messages: any[] };
</file>

<file path="src/index.ts">
export { useAGUIRuntime } from "./useAGUIRuntime";
export type { UseAGUIRuntimeOptions } from "./runtime/types";
</file>

<file path="src/useAGUIRuntime.ts">
"use client";

import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import {
  useExternalStoreRuntime,
  useRuntimeAdapters,
} from "@assistant-ui/react";
import type {
  AssistantRuntime,
  AppendMessage,
  ExternalStoreAdapter,
  ThreadMessage,
} from "@assistant-ui/react";
import type { ReadonlyJSONValue } from "assistant-stream/utils";
import { makeLogger } from "./runtime/logger";
import type { UseAGUIRuntimeOptions } from "./runtime/types";
import { AGUIThreadRuntimeCore } from "./runtime/AGUIThreadRuntimeCore";

export function useAGUIRuntime(
  options: UseAGUIRuntimeOptions,
): AssistantRuntime {
  const logger = useMemo(() => makeLogger(options.logger), [options.logger]);
  const [version, setVersion] = useState(0);
  const notifyUpdate = useCallback(() => setVersion((v) => v + 1), []);
  const coreRef = useRef<AGUIThreadRuntimeCore | null>(null);
  const runtimeAdapters = useRuntimeAdapters();

  const attachmentsAdapter =
    options.adapters?.attachments ?? runtimeAdapters?.attachments;
  const historyAdapter = options.adapters?.history ?? runtimeAdapters?.history;
  const speechAdapter = options.adapters?.speech;
  const feedbackAdapter = options.adapters?.feedback;

  if (!coreRef.current) {
    coreRef.current = new AGUIThreadRuntimeCore({
      agent: options.agent,
      logger,
      showThinking: options.showThinking ?? true,
      ...(options.onError ? { onError: options.onError } : {}),
      ...(options.onCancel ? { onCancel: options.onCancel } : {}),
      ...(historyAdapter ? { history: historyAdapter } : {}),
      notifyUpdate,
    });
  }

  const core = coreRef.current;
  core.updateOptions({
    agent: options.agent,
    logger,
    showThinking: options.showThinking ?? true,
    ...(options.onError ? { onError: options.onError } : {}),
    ...(options.onCancel ? { onCancel: options.onCancel } : {}),
    ...(historyAdapter ? { history: historyAdapter } : {}),
  });

  const adapterAdapters = useMemo(() => {
    const value: NonNullable<ExternalStoreAdapter<ThreadMessage>["adapters"]> =
      {};
    if (attachmentsAdapter) value.attachments = attachmentsAdapter;
    if (speechAdapter) value.speech = speechAdapter;
    if (feedbackAdapter) value.feedback = feedbackAdapter;
    return Object.keys(value).length ? value : undefined;
  }, [attachmentsAdapter, speechAdapter, feedbackAdapter]);

  const store = useMemo(
    () =>
      ({
        messages: core.getMessages(),
        state: core.getState(),
        isRunning: core.isRunning(),
        onNew: (message: AppendMessage) => core.append(message),
        onEdit: (message: AppendMessage) => core.edit(message),
        onReload: (parentId: string | null, config: { runConfig?: any }) =>
          core.reload(parentId, config),
        onCancel: () => core.cancel(),
        onAddToolResult: (options) => core.addToolResult(options),
        onResume: (config) => core.resume(config),
        setMessages: (messages: readonly ThreadMessage[]) =>
          core.applyExternalMessages(messages),
        onImport: (messages: readonly ThreadMessage[]) =>
          core.applyExternalMessages(messages),
        onLoadExternalState: (state: ReadonlyJSONValue) =>
          core.loadExternalState(state),
        adapters: adapterAdapters,
      }) satisfies ExternalStoreAdapter<ThreadMessage>,
    [adapterAdapters, core, version],
  );

  const runtime = useExternalStoreRuntime(store);

  useEffect(() => {
    core.attachRuntime(runtime);
    return () => {
      core.detachRuntime();
    };
  }, [core, runtime]);

  return runtime;
}
</file>

<file path="test/agui-thread-runtime-core.spec.ts">
"use client";

import { describe, expect, it, vi } from "vitest";
import type {
  AppendMessage,
  ThreadAssistantMessage,
  ThreadMessage,
} from "@assistant-ui/react";
import type { HttpAgent } from "@ag-ui/client";
import { AGUIThreadRuntimeCore } from "../src/runtime/AGUIThreadRuntimeCore";
import { makeLogger } from "../src/runtime/logger";

const createAppendMessage = (
  overrides: Partial<AppendMessage> = {},
): AppendMessage => ({
  role: "user",
  content: [{ type: "text" as const, text: "hi" }],
  attachments: [],
  metadata: { custom: {} },
  createdAt: new Date(),
  parentId: overrides.parentId ?? null,
  sourceId: overrides.sourceId ?? null,
  runConfig: overrides.runConfig ?? {},
  startRun: overrides.startRun ?? true,
});

const noopLogger = makeLogger();

const createCore = (
  agent: HttpAgent,
  hooks: { onError?: (e: Error) => void; onCancel?: () => void } = {},
) =>
  new AGUIThreadRuntimeCore({
    agent,
    logger: noopLogger,
    showThinking: true,
    ...(hooks.onError ? { onError: hooks.onError } : {}),
    ...(hooks.onCancel ? { onCancel: hooks.onCancel } : {}),
    notifyUpdate: () => {},
  });

type TestRunConfig = { custom?: Record<string, unknown> };

describe("AGUIThreadRuntimeCore", () => {
  it("streams assistant output into thread messages", async () => {
    const agent = {
      runAgent: vi.fn(async (_input, subscriber) => {
        subscriber.onTextMessageContentEvent?.({
          event: { type: "TEXT_MESSAGE_CONTENT", delta: "Hello" },
        });
        subscriber.onRunFinalized?.();
      }),
    } as unknown as HttpAgent;

    const core = createCore(agent);
    await core.append(createAppendMessage());

    const messages = core.getMessages();
    expect(messages).toHaveLength(2);
    const assistant = messages.at(-1) as ThreadAssistantMessage;
    expect(assistant.role).toBe("assistant");
    expect(assistant.content[0]).toMatchObject({ type: "text", text: "Hello" });
    expect(assistant.status).toMatchObject({
      type: "complete",
      reason: "unknown",
    });
    expect(core.isRunning()).toBe(false);
  });

  it("marks runs as cancelled when aborting", async () => {
    const agent = {
      runAgent: vi.fn((_input, _subscriber, { signal }) => {
        return new Promise((_, reject) => {
          signal.addEventListener("abort", () => {
            const err = new Error("aborted");
            (err as any).name = "AbortError";
            reject(err);
          });
        });
      }),
    } as unknown as HttpAgent;

    const onCancel = vi.fn();
    const core = createCore(agent, { onCancel });
    const promise = core.append(createAppendMessage());
    await core.cancel();
    await promise;

    const assistant = core.getMessages().at(-1) as ThreadAssistantMessage;
    expect(assistant.status).toMatchObject({
      type: "incomplete",
      reason: "cancelled",
    });
    expect(onCancel).toHaveBeenCalledTimes(1);
  });

  it("surfaces errors and rejects append", async () => {
    const agent = {
      runAgent: vi.fn(async () => {
        throw new Error("boom");
      }),
    } as unknown as HttpAgent;

    const onError = vi.fn();
    const core = createCore(agent, { onError });

    await expect(core.append(createAppendMessage())).rejects.toThrow("boom");
    const assistant = core.getMessages().at(-1) as ThreadAssistantMessage;
    expect(assistant.status).toMatchObject({
      type: "incomplete",
      reason: "error",
      error: "boom",
    });
    expect(onError).toHaveBeenCalledTimes(1);
  });

  it("updates tool call result entries", () => {
    const agent = {
      runAgent: vi.fn(async () => {}),
    } as unknown as HttpAgent;

    const toolMessage: ThreadAssistantMessage = {
      id: "assistant",
      role: "assistant",
      createdAt: new Date(),
      status: { type: "complete", reason: "unknown" },
      metadata: {
        unstable_state: null,
        unstable_annotations: [],
        unstable_data: [],
        steps: [],
        custom: {},
      },
      content: [
        {
          type: "tool-call" as const,
          toolCallId: "call-1",
          toolName: "search",
          args: {},
          argsText: "{}",
        },
      ],
    };

    const core = createCore(agent);
    core.applyExternalMessages([toolMessage as ThreadMessage]);

    core.addToolResult({
      messageId: "assistant",
      toolCallId: "call-1",
      toolName: "search",
      result: { ok: true },
      isError: false,
    });

    const updated = core.getMessages()[0] as ThreadAssistantMessage;
    const part = updated.content[0] as any;
    expect(part.result).toEqual({ ok: true });
    expect(part.isError).toBe(false);
  });

  it("resumes runs when requested", async () => {
    const runAgent = vi.fn(async (_input, subscriber) => {
      subscriber.onRunFinalized?.();
    });
    const agent = { runAgent } as unknown as HttpAgent;
    const core = createCore(agent);
    await core.append(createAppendMessage());

    await core.resume({
      parentId: null,
      sourceId: null,
      runConfig: {} as TestRunConfig,
    });

    expect(runAgent).toHaveBeenCalledTimes(2);
  });

  it("omits the placeholder assistant message from run input history", async () => {
    const runAgent = vi.fn(async (_input, subscriber) => {
      subscriber.onRunFinalized?.();
    });
    const agent = { runAgent } as unknown as HttpAgent;

    const core = createCore(agent);
    await core.append(createAppendMessage());

    const input = runAgent.mock.calls[0]?.[0];
    expect(input).toBeTruthy();
    const containsEmptyAssistant = input.messages.some(
      (message: { role: string; content: string }) =>
        message.role === "assistant" && message.content === "",
    );
    expect(containsEmptyAssistant).toBe(false);
  });
});
</file>

<file path="test/conversions.spec.ts">
"use client";

import { describe, it, expect } from "vitest";
import {
  toAGUIMessages,
  toAGUITools,
} from "../src/runtime/adapter/conversions";

describe("adapter conversions", () => {
  it("converts thread messages to AG-UI format", () => {
    const result = toAGUIMessages([
      {
        id: "1",
        role: "user",
        content: [{ type: "text", text: "Hello" }],
      },
      {
        id: "2",
        role: "assistant",
        content: [
          { type: "text", text: "Hi" },
          {
            type: "tool-call",
            toolCallId: "call-1",
            toolName: "search",
            argsText: '{"query":"x"}',
          },
        ],
      },
    ] as any);

    expect(result).toHaveLength(2);
    expect(result[0]).toMatchObject({ role: "user", content: "Hello" });
    const toolCall = (result[1] as any).toolCalls?.[0];
    expect(toolCall).toMatchObject({
      id: "call-1",
      function: { name: "search", arguments: '{"query":"x"}' },
    });
  });

  it("marks errored tool call results with error content", () => {
    const result = toAGUIMessages([
      {
        id: "assistant-1",
        role: "assistant",
        content: [
          {
            type: "tool-call",
            toolCallId: "call-99",
            toolName: "do-it",
            argsText: "{}",
            result: { error: "nope" },
            isError: true,
          },
        ],
      },
    ] as any);

    expect(result).toHaveLength(2);
    expect(result[1]).toMatchObject({
      role: "tool",
      toolCallId: "call-99",
      content: '{"error":"nope"}',
      error: '{"error":"nope"}',
    });
  });

  it("includes tool messages for completed tool calls", () => {
    const result = toAGUIMessages([
      {
        id: "assistant-1",
        role: "assistant",
        content: [
          { type: "text", text: "Working..." },
          {
            type: "tool-call",
            toolCallId: "call-42",
            toolName: "search",
            argsText: '{"query":"x"}',
            result: { ok: true },
          },
        ],
      },
    ] as any);

    expect(result).toHaveLength(2);
    expect(result[0]).toMatchObject({
      role: "assistant",
      content: "Working...",
      toolCalls: [
        {
          id: "call-42",
          function: { name: "search", arguments: '{"query":"x"}' },
        },
      ],
    });
    expect(result[1]).toMatchObject({
      role: "tool",
      toolCallId: "call-42",
      content: '{"ok":true}',
    });
  });

  it("filters disabled/back-end tools", () => {
    const tools = toAGUITools({
      search: { description: "Search", parameters: { type: "object" } },
      disabled: { disabled: true },
      backend: { type: "backend" },
    });

    expect(tools).toHaveLength(1);
    expect(tools[0]).toMatchObject({ name: "search" });
  });

  it("prefers available schema conversion helpers for tools", () => {
    const tools = toAGUITools({
      jsonTool: { parameters: { toJSON: () => ({ type: "object" }) } },
      schemaTool: { parameters: { toJSONSchema: () => ({ type: "string" }) } },
      plain: { parameters: { type: "boolean" } },
    });

    expect(tools).toEqual([
      {
        name: "jsonTool",
        description: undefined,
        parameters: { type: "object" },
      },
      {
        name: "schemaTool",
        description: undefined,
        parameters: { type: "string" },
      },
      {
        name: "plain",
        description: undefined,
        parameters: { type: "boolean" },
      },
    ]);
  });
});
</file>

<file path="test/event-parser.spec.ts">
"use client";

import { describe, it, expect } from "vitest";
import { parseAGUIEvent } from "../src/runtime/event-parser";

describe("parseAGUIEvent", () => {
  it("parses text content event", () => {
    const event = parseAGUIEvent({
      type: "TEXT_MESSAGE_CONTENT",
      messageId: "m1",
      delta: "hi",
    });
    expect(event).toEqual({
      type: "TEXT_MESSAGE_CONTENT",
      messageId: "m1",
      delta: "hi",
    });
  });

  it("guards against invalid events", () => {
    const event = parseAGUIEvent({ type: "TEXT_MESSAGE_CONTENT", delta: "" });
    expect(event).toBeNull();
  });

  it("falls back to RAW for unknown types", () => {
    const event = parseAGUIEvent({ type: "UNKNOWN_EVENT", foo: "bar" });
    expect(event).toEqual({
      type: "RAW",
      event: { type: "UNKNOWN_EVENT", foo: "bar" },
      source: "UNKNOWN_EVENT",
    });
  });
});
</file>

<file path="test/run-aggregator.spec.ts">
"use client";

import { describe, it, expect, beforeEach } from "vitest";
import type { ChatModelRunResult } from "@assistant-ui/react";
import { RunAggregator } from "../src/runtime/adapter/run-aggregator";
import type { AGUIEvent } from "../src/runtime/types";

const makeLogger = () => ({
  debug: () => {},
  error: () => {},
});

describe("RunAggregator", () => {
  let results: ChatModelRunResult[];

  beforeEach(() => {
    results = [];
  });

  const createAggregator = (showThinking: boolean) =>
    new RunAggregator({
      showThinking,
      logger: makeLogger(),
      emit: (update) => results.push(update),
    });

  it("streams text content", () => {
    const aggregator = createAggregator(false);

    aggregator.handle({ type: "RUN_STARTED", runId: "r1" } as AGUIEvent);
    aggregator.handle({
      type: "TEXT_MESSAGE_CONTENT",
      delta: "Hello",
    } as AGUIEvent);
    aggregator.handle({
      type: "TEXT_MESSAGE_CONTENT",
      delta: " world",
    } as AGUIEvent);
    aggregator.handle({ type: "RUN_FINISHED", runId: "r1" } as AGUIEvent);

    const last = results.at(-1);
    expect(last?.status?.type).toBe("complete");
    const textPart = last?.content?.find((part) => part.type === "text");
    expect(textPart).toBeTruthy();
    expect((textPart as any).text).toBe("Hello world");
  });

  it("maps thinking events to reasoning part when enabled", () => {
    const aggregator = createAggregator(true);

    aggregator.handle({ type: "RUN_STARTED", runId: "r1" } as AGUIEvent);
    aggregator.handle({ type: "THINKING_TEXT_MESSAGE_START" } as AGUIEvent);
    aggregator.handle({
      type: "THINKING_TEXT_MESSAGE_CONTENT",
      delta: "Reasoning...",
    } as AGUIEvent);
    aggregator.handle({ type: "THINKING_TEXT_MESSAGE_END" } as AGUIEvent);

    const reasoningPart = results.at(-1)?.content?.[0];
    expect(reasoningPart?.type).toBe("reasoning");
    expect((reasoningPart as any).text).toBe("Reasoning...");
  });

  it("ignores thinking events when disabled", () => {
    const aggregator = createAggregator(false);

    aggregator.handle({ type: "RUN_STARTED", runId: "r1" } as AGUIEvent);
    aggregator.handle({
      type: "THINKING_TEXT_MESSAGE_CONTENT",
      delta: "hidden",
    } as AGUIEvent);

    const parts = results.at(-1)?.content ?? [];
    expect(parts.every((part) => part.type !== "reasoning")).toBe(true);
  });

  it("tracks tool call lifecycle", () => {
    const aggregator = createAggregator(false);

    aggregator.handle({ type: "RUN_STARTED", runId: "r1" } as AGUIEvent);
    aggregator.handle({
      type: "TOOL_CALL_START",
      toolCallId: "tool1",
      toolCallName: "search",
    } as AGUIEvent);
    aggregator.handle({
      type: "TOOL_CALL_ARGS",
      toolCallId: "tool1",
      delta: '{"query":"test"}',
    } as AGUIEvent);
    aggregator.handle({
      type: "TOOL_CALL_RESULT",
      toolCallId: "tool1",
      content: '"result"',
    } as AGUIEvent);

    const last = results.at(-1);
    const toolPart = last?.content?.find((part) => part.type === "tool-call");
    expect(toolPart).toBeTruthy();
    expect((toolPart as any).toolName).toBe("search");
    expect((toolPart as any).argsText).toBe('{"query":"test"}');
    expect((toolPart as any).result).toBe("result");
  });

  it("respects event ordering between tool calls and text", () => {
    const aggregator = createAggregator(false);

    aggregator.handle({ type: "RUN_STARTED", runId: "r1" } as AGUIEvent);
    aggregator.handle({
      type: "TOOL_CALL_START",
      toolCallId: "tool1",
      toolCallName: "search",
    } as AGUIEvent);
    aggregator.handle({
      type: "TOOL_CALL_RESULT",
      toolCallId: "tool1",
      content: '"result"',
    } as AGUIEvent);
    aggregator.handle({
      type: "TEXT_MESSAGE_CONTENT",
      delta: "Final answer",
    } as AGUIEvent);

    const last = results.at(-1);
    const types = (last?.content ?? []).map((part) => part.type);
    expect(types).toEqual(["tool-call", "text"]);
  });

  it("creates additional text parts for subsequent assistant messages", () => {
    const aggregator = createAggregator(false);

    aggregator.handle({ type: "RUN_STARTED", runId: "r1" } as AGUIEvent);
    aggregator.handle({
      type: "TEXT_MESSAGE_START",
      messageId: "m1",
    } as AGUIEvent);
    aggregator.handle({
      type: "TEXT_MESSAGE_CONTENT",
      messageId: "m1",
      delta: "First",
    } as AGUIEvent);
    aggregator.handle({
      type: "TEXT_MESSAGE_END",
      messageId: "m1",
    } as AGUIEvent);
    aggregator.handle({
      type: "TEXT_MESSAGE_START",
      messageId: "m2",
    } as AGUIEvent);
    aggregator.handle({
      type: "TEXT_MESSAGE_CONTENT",
      messageId: "m2",
      delta: "Second",
    } as AGUIEvent);
    aggregator.handle({ type: "RUN_FINISHED", runId: "r1" } as AGUIEvent);

    const last = results.at(-1);
    const textParts = (last?.content ?? []).filter(
      (part) => part.type === "text",
    );
    expect(textParts).toHaveLength(2);
    expect((textParts[0] as any).text).toBe("First");
    expect((textParts[1] as any).text).toBe("Second");
  });

  it("marks status as cancelled", () => {
    const aggregator = createAggregator(false);

    aggregator.handle({ type: "RUN_STARTED", runId: "r1" } as AGUIEvent);
    aggregator.handle({ type: "RUN_CANCELLED" } as AGUIEvent);

    const last = results.at(-1);
    expect(last?.status).toMatchObject({
      type: "incomplete",
      reason: "cancelled",
    });
  });

  it("parses tool call args into an object once JSON becomes valid", () => {
    const aggregator = createAggregator(false);

    aggregator.handle({ type: "RUN_STARTED", runId: "r1" } as AGUIEvent);
    aggregator.handle({
      type: "TOOL_CALL_START",
      toolCallId: "tool1",
      toolCallName: "search",
    } as AGUIEvent);
    aggregator.handle({
      type: "TOOL_CALL_ARGS",
      toolCallId: "tool1",
      delta: '{"query":',
    } as AGUIEvent);
    aggregator.handle({
      type: "TOOL_CALL_ARGS",
      toolCallId: "tool1",
      delta: '"pizza"}',
    } as AGUIEvent);

    const last = results.at(-1);
    const toolPart = last?.content?.find(
      (part) => part.type === "tool-call",
    ) as any;
    expect(toolPart).toBeTruthy();
    expect(toolPart.argsText).toBe('{"query":"pizza"}');
    expect(toolPart.args).toEqual({ query: "pizza" });
  });

  it("positions reasoning content before text when thinking is shown", () => {
    const aggregator = createAggregator(true);

    aggregator.handle({ type: "RUN_STARTED", runId: "r1" } as AGUIEvent);
    aggregator.handle({ type: "THINKING_TEXT_MESSAGE_START" } as AGUIEvent);
    aggregator.handle({
      type: "THINKING_TEXT_MESSAGE_CONTENT",
      delta: "Reasoning first",
    } as AGUIEvent);
    aggregator.handle({
      type: "TEXT_MESSAGE_CONTENT",
      delta: "Then answer",
    } as AGUIEvent);

    const last = results.at(-1);
    const types = (last?.content ?? []).map((part) => part.type);
    expect(types[0]).toBe("reasoning");
    expect(types[1]).toBe("text");
    expect((last?.content?.[0] as any).text).toBe("Reasoning first");
  });

  it("marks run errors with reason and message", () => {
    const aggregator = createAggregator(false);

    aggregator.handle({ type: "RUN_STARTED", runId: "r1" } as AGUIEvent);
    aggregator.handle({ type: "RUN_ERROR", message: "boom" } as AGUIEvent);

    const last = results.at(-1);
    expect(last?.status).toMatchObject({
      type: "incomplete",
      reason: "error",
      error: "boom",
    });
  });

  it("parses tool call results and defaults metadata", () => {
    const aggregator = createAggregator(false);

    aggregator.handle({ type: "RUN_STARTED", runId: "r1" } as AGUIEvent);
    aggregator.handle({
      type: "TOOL_CALL_RESULT",
      toolCallId: "tool1",
      content: '{"ok":true}',
      role: "tool",
    } as AGUIEvent);

    const last = results.at(-1);
    const toolPart = last?.content?.find(
      (part) => part.type === "tool-call",
    ) as any;
    expect(toolPart).toBeTruthy();
    expect(toolPart.toolName).toBe("tool");
    expect(toolPart.result).toEqual({ ok: true });
    expect(toolPart.isError).toBe(false);
  });
});
</file>

<file path="test/subscriber.spec.ts">
"use client";

import { describe, it, expect, vi } from "vitest";
import { createAGUISubscriber } from "../src/runtime/adapter/subscriber";
import type { AGUIEvent } from "../src/runtime/types";

describe("createAGUISubscriber", () => {
  it("dispatches typed events without duplication", () => {
    const events: AGUIEvent[] = [];
    const subscriber = createAGUISubscriber({
      dispatch: (evt) => events.push(evt),
      runId: "run",
    });

    subscriber.onTextMessageContentEvent?.({ event: { delta: "Hi" } });
    subscriber.onEvent?.({
      event: { type: "TEXT_MESSAGE_CONTENT", delta: "ignored" },
    });

    expect(events).toHaveLength(1);
    expect(events[0]).toMatchObject({
      type: "TEXT_MESSAGE_CONTENT",
      delta: "Hi",
    });
  });

  it("dispatches run error and invokes hook", () => {
    const events: AGUIEvent[] = [];
    const onRunFailed = vi.fn();
    const subscriber = createAGUISubscriber({
      dispatch: (evt) => events.push(evt),
      runId: "run",
      onRunFailed,
    });

    const error = new Error("boom");
    subscriber.onRunFailed?.({ error });

    expect(onRunFailed).toHaveBeenCalledWith(error);
    expect(events).toHaveLength(1);
    expect(events[0]).toMatchObject({ type: "RUN_ERROR", message: "boom" });
  });
});
</file>

<file path="package.json">
{
  "name": "@assistant-ui/react-agui",
  "version": "0.0.0",
  "license": "MIT",
  "type": "module",
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "default": "./dist/index.js"
    }
  },
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "files": [
    "dist",
    "src",
    "README.md"
  ],
  "sideEffects": false,
  "scripts": {
    "build": "tsx scripts/build.mts",
    "lint": "eslint .",
    "test": "vitest",
    "test:run": "vitest run"
  },
  "dependencies": {
    "@ag-ui/client": "^0.0.40",
    "assistant-stream": "workspace:*"
  },
  "peerDependencies": {
    "@assistant-ui/react": "^0.11.29",
    "@types/react": "*",
    "react": "^18 || ^19 || ^19.0.0-rc"
  },
  "peerDependenciesMeta": {
    "@types/react": {
      "optional": true
    }
  },
  "devDependencies": {
    "@assistant-ui/react": "workspace:*",
    "@assistant-ui/x-buildutils": "workspace:*",
    "@types/node": "^24.6.2",
    "@types/react": "^19.2.0",
    "eslint": "^9",
    "eslint-config-next": "15.5.4",
    "react": "19.2.0",
    "tsx": "^4.20.6",
    "vitest": "^3.2.4",
    "jsdom": "^27.0.0"
  },
  "publishConfig": {
    "access": "public",
    "provenance": true
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/assistant-ui/assistant-ui/tree/main/packages/react-agui"
  },
  "bugs": {
    "url": "https://github.com/assistant-ui/assistant-ui/issues"
  }
}
</file>

<file path="tsconfig.json">
{
  "extends": "../x-buildutils/ts/base.json",
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@assistant-ui/react": ["../react/src"],
      "assistant-stream": ["../assistant-stream/src/index.ts"],
      "assistant-stream/*": ["../assistant-stream/src/*"]
    }
  },
  "include": ["src/**/*.ts", "src/**/*.tsx"],
  "exclude": ["**/*.test.ts", "**/*.test.tsx", "**/*.spec.ts", "**/*.spec.tsx"]
}
</file>

</files>

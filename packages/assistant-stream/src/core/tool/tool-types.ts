import { JSONSchema7 } from "json-schema";
import { DeepPartial, TypeAtPath, TypePath } from "./type-path-utils";
import { AsyncIterableStream, ReadonlyJSONObject } from "../../utils";
import type { StandardSchemaV1 } from "@standard-schema/spec";
import { ToolResponse } from "./ToolResponse";
import { z } from "zod";
import { Tool as AITool, Schema } from "ai";
import { ComponentType } from "react";

/**
 * Interface for reading tool call arguments from a stream, which are
 * generated by a language learning model (LLM). Provides methods to
 * retrieve specific values, partial streams, or complete items from
 * an array, based on a specified path.
 *
 * @template TArgs The type of arguments being read.
 */
export interface ToolCallArgsReader<TArgs extends Record<string, unknown>> {
  /**
   * Returns a promise that will resolve to the value at the given path,
   * as soon as that path is generated by the LLM.
   *
   * @param fieldPath An array of object keys or array indices.
   */
  get<PathT extends TypePath<TArgs>>(
    ...fieldPath: PathT
  ): Promise<TypeAtPath<TArgs, PathT>>;

  /**
   * Returns a stream that will emit partial values at the given path,
   * as they are generated by the LLM.
   *
   * @param fieldPath An array of object keys or array indices.
   */
  streamValues<PathT extends TypePath<TArgs>>(
    ...fieldPath: PathT
  ): AsyncIterableStream<DeepPartial<TypeAtPath<TArgs, PathT>>>;

  /**
   * Returns a stream that will emit partial text at the given path,
   * as they are generated by the LLM.
   *
   * @param fieldPath An array of object keys or array indices.
   */
  streamText<PathT extends TypePath<TArgs>>(
    ...fieldPath: PathT
  ): TypeAtPath<TArgs, PathT> extends string & infer U
    ? AsyncIterableStream<U>
    : never;

  /**
   * Returns a stream that will emit complete items in the array
   * at the given path, as they are generated by the LLM.
   *
   * @param fieldPath An array of object keys or array indices.
   */
  forEach<PathT extends TypePath<TArgs>>(
    ...fieldPath: PathT
  ): TypeAtPath<TArgs, PathT> extends Array<infer U>
    ? AsyncIterableStream<U>
    : never;
}

export interface ToolCallResponseReader<TResult> {
  get: () => Promise<ToolResponse<TResult>>;
}

export interface ToolCallReader<
  TArgs extends Record<string, unknown> = Record<string, unknown>,
  TResult = unknown,
> {
  args: ToolCallArgsReader<TArgs>;
  response: ToolCallResponseReader<TResult>;

  /**
   * @deprecated Deprecated. Use `response.get().result` instead.
   */
  result: {
    get: () => Promise<TResult>;
  };
}

type ToolExecutionContext = {
  toolCallId: string;
  abortSignal: AbortSignal;
};

export type ToolExecuteFunction<TArgs, TResult> = (
  args: TArgs,
  context: ToolExecutionContext,
) => TResult | Promise<TResult>;

export type ToolStreamCallFunction<
  TArgs extends Record<string, unknown> = Record<string, unknown>,
  TResult = unknown,
> = (
  reader: ToolCallReader<TArgs, TResult>,
  context: ToolExecutionContext,
) => void;

// // CG TODO: Reimplement this
// type OnSchemaValidationErrorFunction<TResult> = ToolExecuteFunction<
//   unknown,
//   TResult
// >;

type ToolBase<
  TArgs extends Record<string, unknown> = Record<string, unknown>,
  TResult = unknown,
> = {
  /**
   * @deprecated Experimental, API may change.
   */
  streamCall?: ToolStreamCallFunction<TArgs, TResult>;
};

type InferArgsFromParameters<T> =
  T extends StandardSchemaV1<infer U>
    ? U extends Record<string, unknown>
      ? U
      : Record<string, unknown>
    : T extends JSONSchema7
      ? Record<string, unknown>
      : T extends z.ZodTypeAny
        ? z.infer<T>
        : Record<string, unknown>;

// Overloaded BackendTool type for better inference
export type BackendTool<
  TParameters = JSONSchema7 | StandardSchemaV1 | z.ZodTypeAny | Schema,
  TResult = unknown,
> = {
  type?: "backend" | undefined;
  description?: string;
  parameters?: TParameters;
  disabled?: undefined;
  execute?: ToolExecuteFunction<InferArgsFromParameters<TParameters>, TResult>;
  experimental_onSchemaValidationError?: undefined;
  streamCall?: undefined;
};

// Overloads for backendTool helper
export function backendTool<
  // Zod type any is here to support users who haven't upgraded to v4
  TParameters extends JSONSchema7 | StandardSchemaV1 | z.ZodTypeAny | Schema,
  TResult,
>(
  tool: Omit<BackendTool<TParameters, TResult>, "execute"> & {
    execute: (
      args: InferArgsFromParameters<TParameters>,
      context: ToolExecutionContext,
    ) => TResult | Promise<TResult>;
  },
): BackendTool<TParameters, TResult> {
  return tool;
}

// Updated backendTools to accept any record of values extending BackendTool with specific generics
export const backendTools = <T extends Record<string, BackendTool>>(
  tools: T,
): T => tools;

export type FrontendTool<
  TParameters = JSONSchema7 | StandardSchemaV1 | z.ZodTypeAny,
  TResult = unknown,
> = {
  type?: "frontend" | undefined;
  description?: string;
  parameters?: TParameters;
  disabled?: undefined;
  execute?: ToolExecuteFunction<InferArgsFromParameters<TParameters>, TResult>;
  render?:
    | ComponentType<
        ToolCallContentPartProps<
          InferArgsFromParameters<TParameters>,
          Awaited<
            ReturnType<
              ToolExecuteFunction<InferArgsFromParameters<TParameters>, TResult>
            >
          >
        >
      >
    | false;
  experimental_onSchemaValidationError?: undefined;
  streamCall?: undefined;
};

export type ToolCallContentPart<
  TArgs = ReadonlyJSONObject,
  TResult = unknown,
> = {
  readonly type: "tool-call";
  readonly toolCallId: string;
  readonly toolName: string;
  readonly args: TArgs;
  readonly result?: TResult | undefined;
  readonly isError?: boolean | undefined;
  readonly argsText: string;
  readonly artifact?: unknown;
};

export type ToolCallContentPartProps<
  TArgs = any,
  TResult = unknown,
> = ToolCallContentPart<TArgs, TResult> & {
  addResult: (result: TResult) => void;
};

export function frontendTool<
  // Zod type any is here to support users who haven't upgraded to v4
  TParameters extends JSONSchema7 | StandardSchemaV1 | z.ZodTypeAny,
  TResult,
>(
  tool: Omit<FrontendTool<TParameters, TResult>, "execute"> & {
    execute: (
      args: InferArgsFromParameters<TParameters>,
      context: ToolExecutionContext,
    ) => TResult | Promise<TResult>;
  },
): FrontendTool<TParameters, TResult> {
  return tool;
}

export type HumanTool<
  TParameters = JSONSchema7 | StandardSchemaV1 | z.ZodTypeAny,
  TResult = unknown,
> = ToolBase<InferArgsFromParameters<TParameters>, TResult> & {
  type?: "human" | undefined;
  description?: string;
  parameters?: TParameters;
  disabled?: undefined;
  execute?: ToolExecuteFunction<InferArgsFromParameters<TParameters>, TResult>;
  // render?: ComponentType<
  //   ToolCallContentPartProps<
  //     InferArgsFromParameters<TParameters>,
  //     Awaited<
  //       ReturnType<
  //         ToolExecuteFunction<InferArgsFromParameters<TParameters>, TResult>
  //       >
  //     >
  //   >
  // >;
  experimental_onSchemaValidationError?: undefined;
  streamCall?: undefined;
};

export type Tool<
  TArgs extends Record<string, unknown> = Record<string, unknown>,
  TResult = unknown,
> =
  | FrontendTool<TArgs, TResult>
  | BackendTool<TArgs, TResult>
  | HumanTool<TArgs, TResult>;

export const toAISDKTool = <T extends BackendTool>(tool: T): AITool => {
  console.log("tool: ", tool);
  const result: any = {
    description: tool.description,
    parameters: tool.parameters,
    execute: tool.execute,
  };
  if (tool.experimental_onSchemaValidationError !== undefined) {
    result.experimental_onSchemaValidationError =
      tool.experimental_onSchemaValidationError;
  }
  if (tool.streamCall !== undefined) {
    result.streamCall = tool.streamCall;
  }

  return {
    description: tool.description,
    parameters: tool.parameters,
    execute: tool.execute,
  } as AITool;
};

---
title: Message Part Grouping
---

import { Steps, Step } from "fumadocs-ui/components/steps";
import { Callout } from "fumadocs-ui/components/callout";
import { ParametersTable } from "@/components/docs";

## Overview

<Callout type="warn">
  This feature is experimental and the API may change in future versions.
</Callout>

The Parent ID Grouping feature allows you to group related message parts together by assigning them a common `parentId`. This is useful for organizing content hierarchically, such as grouping research sources with their findings, or organizing multi-step tool executions.

### Use it in your application

The message part grouping feature provides two ways to group message parts:

1. **PartsGroupedByParentId** - Groups parts by their parent ID (simplified API)
2. **PartsGrouped** - Groups parts using a custom grouping function (flexible API)

#### Using PartsGroupedByParentId

Use the `MessagePrimitive.Unstable_PartsGroupedByParentId` component instead of the regular `MessagePrimitive.Parts` component:

```tsx twoslash title="/components/assistant-ui/thread.tsx"
import { FC, PropsWithChildren } from "react";
import { MessagePrimitive } from "@assistant-ui/react";

const AssistantActionBar: FC = () => null;
const BranchPicker: FC<{ className?: string }> = () => null;

// ---cut---
const ParentIdGroup: FC<
  PropsWithChildren<{ parentId: string | undefined; indices: number[] }>
> = ({ parentId, indices, children }) => {
  if (!parentId) {
    // Ungrouped parts - render directly
    return <>{children}</>;
  }

  return (
    <div className="bg-muted/20 my-2 rounded-lg border p-4">
      <div className="mb-2 text-sm font-medium">
        Group: {parentId} ({indices.length} parts)
      </div>
      <div className="space-y-2">{children}</div>
    </div>
  );
};

const AssistantMessage: FC = () => {
  return (
    <MessagePrimitive.Root className="...">
      <div className="...">
        <MessagePrimitive.Unstable_PartsGroupedByParentId
          components={{ Group: ParentIdGroup }}
        />
      </div>
      <AssistantActionBar />

      <BranchPicker className="..." />
    </MessagePrimitive.Root>
  );
};
```

#### Using PartsGrouped (Custom Grouping)

For more control over how parts are grouped, use the `MessagePrimitive.Unstable_PartsGrouped` component with a custom grouping function:

```tsx twoslash title="/components/assistant-ui/thread.tsx"
import { FC, PropsWithChildren } from "react";
import { MessagePrimitive } from "@assistant-ui/react";

const AssistantActionBar: FC = () => null;
const BranchPicker: FC<{ className?: string }> = () => null;

// ---cut---
// Custom grouping function that groups by tool name
const groupByToolName = (parts: readonly any[]) => {
  const groups = new Map<string, number[]>();
  
  for (let i = 0; i < parts.length; i++) {
    const part = parts[i];
    // Group tool calls by tool name
    const groupKey = part.type === "tool-call" ? part.toolName : `__other_${i}`;
    
    const indices = groups.get(groupKey) ?? [];
    indices.push(i);
    groups.set(groupKey, indices);
  }
  
  return Array.from(groups.entries()).map(([groupKey, indices]) => ({
    groupKey: groupKey.startsWith("__other_") ? undefined : groupKey,
    indices
  }));
};

const ToolGroup: FC<
  PropsWithChildren<{ groupKey: string | undefined; indices: number[] }>
> = ({ groupKey, indices, children }) => {
  if (!groupKey) return <>{children}</>;
  
  return (
    <div className="tool-group my-2 rounded-lg border">
      <div className="bg-muted/50 px-4 py-2 text-sm font-medium">
        Tool: {groupKey} ({indices.length} calls)
      </div>
      <div className="p-4">{children}</div>
    </div>
  );
};

const AssistantMessage: FC = () => {
  return (
    <MessagePrimitive.Root className="...">
      <div className="...">
        <MessagePrimitive.Unstable_PartsGrouped
          groupingFunction={groupByToolName}
          components={{ Group: ToolGroup }}
        />
      </div>
      <AssistantActionBar />

      <BranchPicker className="..." />
    </MessagePrimitive.Root>
  );
};
```

## How it works

1. **Message parts with parent IDs**: Add a `parentId` field to your message parts:

   ```typescript
   {
     type: "text",
     text: "Research finding about climate change",
     parentId: "climate-research"
   }
   ```

2. **Automatic grouping**: Parts with the same `parentId` are automatically grouped together

3. **Ordering**: Groups appear in the order of the first occurrence of each parent ID

4. **Ungrouped parts**: Parts without a `parentId` appear after all grouped parts

## Setting Parent IDs

### In Python (assistant-stream)

Use the `with_parent_id()` method on the RunController:

```python
from assistant_stream import create_run

async def my_run(controller):
    # Regular message part
    controller.append_text("Starting research...")

    # Grouped parts with parent ID
    research_controller = controller.with_parent_id("research-123")

    await research_controller.add_tool_call("search", {"query": "climate data"})
    research_controller.append_source({
        "id": "source-1",
        "url": "https://example.com/climate-data",
        "title": "Climate Data Report"
    })
    research_controller.append_text("Key findings from the research:")
    research_controller.append_text("‚Ä¢ Global temperatures rising")
    research_controller.append_text("‚Ä¢ Sea levels increasing")

    # Back to ungrouped content
    controller.append_text("In conclusion...")
```

### In TypeScript (assistant-stream)

Use the `withParentId()` method on the AssistantStreamController:

```typescript
import { createAssistantStream } from "@assistant-ui/react/assistant-stream";

const stream = createAssistantStream(async (controller) => {
  // Regular message part
  controller.appendText("Starting research...");

  // Grouped parts with parent ID
  const researchController = controller.withParentId("research-123");

  await researchController.addToolCallPart({
    toolName: "search",
    args: { query: "climate data" },
  });
  researchController.appendSource({
    type: "source",
    id: "source-1",
    url: "https://example.com/climate-data",
    title: "Climate Data Report",
  });
  researchController.appendText("Key findings from the research:");
  researchController.appendText("‚Ä¢ Global temperatures rising");
  researchController.appendText("‚Ä¢ Sea levels increasing");

  // Back to ungrouped content
  controller.appendText("In conclusion...");
});
```

### With External Store

When using the external store runtime, include the `parentId` in your message parts:

```typescript
const messages = [
  {
    role: "assistant",
    content: [
      {
        type: "text",
        text: "Let me search for information...",
      },
      {
        type: "tool-call",
        toolCallId: "call-1",
        toolName: "search",
        args: { query: "climate change" },
        parentId: "search-results",
      },
      {
        type: "source",
        sourceType: "url",
        id: "source-1",
        url: "https://example.com",
        title: "Climate Report",
        parentId: "search-results",
      },
      {
        type: "text",
        text: "Based on the search results:",
        parentId: "search-results",
      },
    ],
  },
];
```

## Props

The Group component receives the following props:

- `parentId`: The parent ID shared by all parts in this group (undefined for ungrouped parts)
- `indices`: Array of indices for the parts in this group
- `children`: The rendered message part components

## Examples

### Collapsible Research Groups

```tsx
import { useState } from "react";
import { ChevronDownIcon, ChevronUpIcon } from "lucide-react";

const CollapsibleGroup: FC<
  PropsWithChildren<{ parentId: string | undefined; indices: number[] }>
> = ({ parentId, indices, children }) => {
  const [isCollapsed, setIsCollapsed] = useState(false);

  if (!parentId) return <>{children}</>;

  return (
    <div className="my-2 overflow-hidden rounded-lg border">
      <button
        onClick={() => setIsCollapsed(!isCollapsed)}
        className="hover:bg-muted/50 flex w-full items-center justify-between p-3"
      >
        <span>Research Group ({indices.length} items)</span>
        {isCollapsed ? <ChevronDownIcon /> : <ChevronUpIcon />}
      </button>
      {!isCollapsed && <div className="border-t p-3">{children}</div>}
    </div>
  );
};
```

### Labeled Groups with Icons

```tsx
const LabeledGroup: FC<
  PropsWithChildren<{ parentId: string | undefined; indices: number[] }>
> = ({ parentId, indices, children }) => {
  if (!parentId) return <>{children}</>;

  const getGroupLabel = (id: string) => {
    if (id.includes("research")) return "üîç Research";
    if (id.includes("analysis")) return "üìä Analysis";
    if (id.includes("summary")) return "üìù Summary";
    return "üìÅ " + id;
  };

  return (
    <div className="bg-muted/30 my-3 rounded-lg p-4">
      <h4 className="mb-2 text-sm font-semibold">{getGroupLabel(parentId)}</h4>
      <div className="space-y-2">{children}</div>
    </div>
  );
};
```

## Use Cases

Parent ID grouping is particularly useful for:

- **Research assistants**: Group sources, findings, and analysis together
- **Multi-step processes**: Organize related tool calls and their results
- **Hierarchical content**: Create nested or categorized information structures
- **Context preservation**: Keep related information visually connected

## API Reference

### MessagePrimitive.Unstable_PartsGrouped

The flexible API for grouping message parts with custom logic.

<ParametersTable
  type="MessagePrimitiveUnstable_PartsGroupedProps"
  parameters={[
    {
      name: "groupingFunction",
      type: "(parts: readonly any[]) => MessagePartGroup[]",
      description: "Function that takes an array of message parts and returns an array of groups. Each group contains a groupKey (for identification) and an array of indices.",
      required: true
    },
    {
      name: "components",
      type: "object",
      description: "Component configuration for rendering different types of message content and groups.",
      children: [
        {
          name: "Empty",
          type: "EmptyMessagePartComponent",
          description: "Component for rendering empty messages"
        },
        {
          name: "Text",
          type: "TextMessagePartComponent",
          description: "Component for rendering text content"
        },
        {
          name: "Reasoning",
          type: "ReasoningMessagePartComponent",
          description: "Component for rendering reasoning content (typically hidden)"
        },
        {
          name: "Source",
          type: "SourceMessagePartComponent",
          description: "Component for rendering source content"
        },
        {
          name: "Image",
          type: "ImageMessagePartComponent",
          description: "Component for rendering image content"
        },
        {
          name: "File",
          type: "FileMessagePartComponent",
          description: "Component for rendering file content"
        },
        {
          name: "Unstable_Audio",
          type: "Unstable_AudioMessagePartComponent",
          description: "Component for rendering audio content (experimental)"
        },
        {
          name: "tools",
          type: "object | { Override: ComponentType }",
          description: "Configuration for tool call rendering. Can be an object with by_name map and Fallback component, or an Override component."
        },
        {
          name: "Group",
          type: "ComponentType<{ groupKey: string | undefined; indices: number[]; children: ReactNode }>",
          description: "Component for rendering grouped message parts. Receives groupKey, indices array, and children to render."
        }
      ]
    }
  ]}
/>

#### MessagePartGroup Type

The grouping function returns an array of `MessagePartGroup` objects:

```typescript
type MessagePartGroup = {
  groupKey: string | undefined;  // The group identifier (undefined for ungrouped parts)
  indices: number[];             // Array of part indices belonging to this group
};
```

#### Grouping Function Examples

```typescript
// Group by parent ID (built-in default)
const groupByParentId = (parts: readonly any[]) => {
  const groups = new Map<string, number[]>();
  
  for (let i = 0; i < parts.length; i++) {
    const part = parts[i];
    const groupId = part?.parentId ?? `__ungrouped_${i}`;
    
    const indices = groups.get(groupId) ?? [];
    indices.push(i);
    groups.set(groupId, indices);
  }
  
  return Array.from(groups.entries()).map(([groupId, indices]) => ({
    groupKey: groupId.startsWith("__ungrouped_") ? undefined : groupId,
    indices
  }));
};

// Group consecutive text parts
const groupConsecutiveText = (parts: readonly any[]) => {
  const groups: MessagePartGroup[] = [];
  let currentGroup: number[] = [];
  let isTextGroup = false;
  
  for (let i = 0; i < parts.length; i++) {
    const isText = parts[i].type === "text";
    
    if (isText === isTextGroup && currentGroup.length > 0) {
      currentGroup.push(i);
    } else {
      if (currentGroup.length > 0) {
        groups.push({
          groupKey: isTextGroup ? "text-block" : undefined,
          indices: currentGroup
        });
      }
      currentGroup = [i];
      isTextGroup = isText;
    }
  }
  
  if (currentGroup.length > 0) {
    groups.push({
      groupKey: isTextGroup ? "text-block" : undefined,
      indices: currentGroup
    });
  }
  
  return groups;
};
```

### MessagePrimitive.Unstable_PartsGroupedByParentId

A convenience wrapper that uses parent ID grouping by default.

<ParametersTable
  type="MessagePrimitiveUnstable_PartsGroupedByParentIdProps"
  parameters={[
    {
      name: "components",
      type: "object",
      description: "Same component configuration as PartsGrouped, for rendering different types of message content and groups."
    }
  ]}
/>

<Callout>
  The PartsGroupedByParentId component is equivalent to using PartsGrouped with the built-in `groupMessagePartsByParentId` function.
</Callout>

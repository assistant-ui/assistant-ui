---
title: Picking a Runtime
---

import { Card, Cards } from "fumadocs-ui/components/card";
import { Callout } from "fumadocs-ui/components/callout";

Building an AI chat application requires choosing the right runtime for managing conversations, connecting to language models, and handling persistence. This guide helps you make an informed decision based on your specific requirements.

## Quick Decision Guide

<Cards>
  <Card
    title="I want the fastest setup"
    description="Use LocalRuntime - manages state internally with adapter extensibility"
    href="/docs/runtimes/custom/local"
  />
  <Card
    title="I have existing state management"
    description="Use ExternalStoreRuntime - integrates with Redux, Zustand, etc."
    href="/docs/runtimes/custom/external-store"
  />
  <Card
    title="I need multi-thread support"
    description="Use LocalRuntime + Assistant Cloud or ExternalStoreRuntime + custom adapter"
    href="/docs/cloud/overview"
  />
  <Card
    title="I'm using Vercel AI SDK"
    description="Use the AI SDK runtime integration"
    href="/docs/runtimes/ai-sdk/use-chat"
  />
</Cards>

## Key Considerations

### 1. State Management Requirements

**How much control do you need over message state?**

- **Minimal** → Use **[LocalRuntime](/docs/runtimes/custom/local)** - Built-in state management with adapter-based extensibility
- **Full control** → Use **[ExternalStoreRuntime](/docs/runtimes/custom/external-store)** - You manage all state, perfect for Redux/Zustand integration
- **Existing state** → Use **[ExternalStoreRuntime](/docs/runtimes/custom/external-store)** - Seamlessly integrate with your current state management

### 2. Multi-Thread Support

**Do you need multiple conversation threads?**

- **Single thread** → Either runtime works
- **Multiple threads with cloud** → Use **LocalRuntime + Assistant Cloud**
- **Multiple threads with custom storage** → Use **ExternalStoreRuntime + thread list adapter**

<Callout>
**LocalRuntime** supports multiple threads when paired with Assistant Cloud. Without cloud, it manages a single conversation. For custom multi-thread implementations, use ExternalStoreRuntime.
</Callout>

### 3. Persistence & Storage

**How will you store conversation history?**

- **Assistant Cloud** (Easiest) - Managed persistence with auth, multi-device sync, and free tier
- **Custom database** - Use adapters with either runtime
- **Client-side only** - Good for demos, messages lost on refresh
- **Existing storage** - Use ExternalStoreRuntime to integrate with your persistence layer

### 4. Language Model Integration

**Which LLM are you using?**

- **OpenAI/Anthropic/Custom API** → Either runtime with appropriate adapter
- **Vercel AI SDK** → Use the [AI SDK runtime](/docs/runtimes/ai-sdk/use-chat)
- **LangGraph agents** → Use [LangGraph runtime](/docs/runtimes/langgraph)
- **Multiple models** → Either runtime with dynamic model selection

## Runtime Comparison

| Feature               | LocalRuntime                         | ExternalStoreRuntime                | AI SDK             |
| --------------------- | ------------------------------------ | ----------------------------------- | ------------------ |
| **Setup Complexity**  | Simple                               | Moderate                            | Simple             |
| **State Control**     | Managed internally                   | Full control                        | Managed            |
| **Multi-thread**      | Yes (with Assistant Cloud)           | Yes (with thread list adapter)      | Depends            |
| **Message Format**    | ThreadMessage                        | Any (with conversion)               | AI SDK format      |
| **Persistence**       | Via adapters or Cloud                | You implement                       | Via adapters       |
| **Extensibility**     | Adapter system                       | Handler-based                       | Limited            |
| **Best For**          | Most use cases, quick starts         | Complex state, existing state mgmt  | Vercel projects    |

## Implementation Patterns

### Pattern 1: Simple Chat App

For most chat applications, start with [LocalRuntime](/docs/runtimes/custom/local):

```tsx
import { useLocalRuntime } from "@assistant-ui/react";

const adapter = {
  async run({ messages, abortSignal }) {
    const response = await fetch("/api/chat", {
      method: "POST",
      body: JSON.stringify({ messages }),
      signal: abortSignal,
    });
    return response.json();
  },
};

const runtime = useLocalRuntime(adapter);
```

### Pattern 2: Multi-Thread Chat

Two approaches for multi-thread support:

```tsx
// Option 1: LocalRuntime + Assistant Cloud
import { useLocalRuntime } from "@assistant-ui/react";
import { AssistantCloud } from "@assistant-ui/cloud";

const cloud = new AssistantCloud({ apiKey: "..." });
const runtime = useLocalRuntime(adapter, { cloud });
// Full thread management included!

// Option 2: ExternalStoreRuntime + Custom Storage
const runtime = useExternalStoreRuntime({
  messages: currentThreadMessages,
  onNew,
  adapters: {
    threadList: {
      threads,
      onSwitchToThread,
      onRename,
      onDelete,
      // ... other handlers
    },
  },
});
```

### Pattern 3: Integration with Redux/Zustand

For existing state management, use [ExternalStoreRuntime](/docs/runtimes/custom/external-store):

```tsx
import { useExternalStoreRuntime } from "@assistant-ui/react";
import { useSelector, useDispatch } from "react-redux";

const messages = useSelector(selectMessages);
const dispatch = useDispatch();

const runtime = useExternalStoreRuntime({
  messages,
  setMessages: (msgs) => dispatch(setMessages(msgs)),
  onNew: async (message) => {
    dispatch(addUserMessage(message));
    const response = await api.chat(message);
    dispatch(addAssistantMessage(response));
  },
});
```

## Feature-by-Feature Guide

### Adapters Available

| Adapter | LocalRuntime | ExternalStoreRuntime |
| ------- | ------------ | -------------------- |
| ChatModel | ✅ Required | ❌ N/A |
| Attachments | ✅ | ✅ |
| Speech | ✅ | ✅ |
| Feedback | ✅ | ✅ |
| History | ✅ | ❌ (use state) |
| Suggestions | ✅ | ❌ (use state) |
| Thread List | ❌ (use Cloud) | ✅ |

### UI Features & Requirements

| Feature | LocalRuntime | ExternalStoreRuntime Requirement |
| ------- | ------------ | --------------------------------- |
| Message Display | Automatic | Provide `messages` |
| Send Messages | Automatic | Provide `onNew` |
| Edit Messages | Automatic | Provide `onEdit` |
| Regenerate | Automatic | Provide `onReload` |
| Branch Switching | Automatic | Provide `setMessages` |
| Cancel Generation | Automatic | Provide `onCancel` |
| Multi-thread | With Cloud | Provide thread list adapter |

## Deployment Considerations

### Serverless (Vercel, Netlify)

- Use **AI SDK runtime** for optimal Vercel integration
- Consider edge runtime for low latency
- Use Assistant Cloud for persistence (no database needed)

### Traditional Server (Node.js, Python)

- **LocalRuntime** works with any backend
- Can use server-side state management
- Direct database connections possible

### Static Sites

- Use **LocalRuntime** with client-side API calls
- Consider CORS for API endpoints
- Assistant Cloud handles auth without backend

## Decision Framework

### Start with LocalRuntime when:

- Building a new chat application
- You want automatic state management
- You need quick prototyping
- Using Assistant Cloud for persistence
- Building single or multi-thread apps with cloud

### Use ExternalStoreRuntime when:

- You have existing state management (Redux, Zustand, etc.)
- You need custom message persistence logic
- Building complex multi-thread without cloud
- You need full control over state updates
- Integrating chat into a larger application

### Common Scenarios

| Scenario | Recommended Runtime |
| -------- | ------------------- |
| Simple chatbot | LocalRuntime |
| Customer support with history | LocalRuntime + Cloud |
| Chat in existing React app | ExternalStoreRuntime |
| Multi-user collaboration | LocalRuntime + Cloud |
| Custom thread management | ExternalStoreRuntime |
| Prototype/Demo | LocalRuntime |

## Migration Paths

### LocalRuntime → ExternalStoreRuntime

If you start with LocalRuntime and need more control:

1. Extract your messages to external state
2. Implement required handlers (onNew, onEdit, etc.)
3. Move adapters to the new runtime
4. Add thread list adapter if using custom multi-thread

### ExternalStoreRuntime → LocalRuntime

If you want to simplify:

1. Remove external state management
2. Convert handlers to LocalRuntime adapters
3. Add Assistant Cloud for multi-thread support
4. Simplify your codebase

## Next Steps

1. **Choose your runtime** based on your requirements
2. **Start with examples**:
   - [LocalRuntime Example](https://github.com/assistant-ui/assistant-ui/tree/main/examples/with-local-runtime)
   - [ExternalStoreRuntime Example](https://github.com/assistant-ui/assistant-ui/tree/main/examples/with-external-store)
3. **Add features progressively** with adapters
4. **Consider Assistant Cloud** for production persistence


---
title: Component State Hydration and Replay
description: Deterministic lifecycle and state replay for component message parts using instanceId-scoped patches.
---

import { Stage1ComponentParity } from "@/components/examples/stage1-component-parity";

This page documents deterministic read-path behavior for component lifecycle
and state synchronization.

## Audience

- Primary: runtime integrators and assistant-ui maintainers validating component
  state semantics.
- If you are implementing a standard AI SDK runtime integration, start with
  [AI SDK v6 Runtime](/docs/runtimes/ai-sdk/v6) and use this page as a
  reference for `instanceId` + patch behavior details.

## Plain-language mental model

Treat each component like a mini app with an ID.

- `instanceId` tells you *which* mini app to update.
- `state` is the mini app's current data.
- `seq` is the update order number.
- If an old update arrives late, ignore it.

This prevents flicker and "jumping backwards" when streaming updates arrive out
of order.

## What this guarantees

- `component.instanceId` is required and used as the state key.
- `metadata.unstable_state.components[instanceId]` is the canonical storage
  location.
- Patch protocol is `aui-state` `v1` with only `set` and `append-text`.
- Per-instance `seq` is monotonic. Updates apply only when
  `incomingSeq > currentSeq`.
- Stale patches are dropped deterministically.

## Runnable replay demo

The demo below replays a deterministic fixture sequence:

1. mount component `card_1` (`seq=1`, `lifecycle=mounting`)
2. apply `seq=2` patch (`lifecycle=active`, append `state.summary`)
3. drop stale `seq=1` patch trying to set `lifecycle=complete`

<Stage1ComponentParity />

### What to look for in the demo

1. The card starts in `mounting`.
2. A newer update (`seq=2`) moves it to `active` and appends text.
3. An older update (`seq=1`) is rejected as stale.

If your product has streaming latency, this is the behavior that keeps UI state
trustworthy.

## Bridge migration notes

When migrating existing external bridge runtime code to these semantics:

1. emit `instanceId` on every component part
2. write component state under `components/<instanceId>/...`
3. include numeric `seq` in each patch batch
4. keep operation set limited to `set` and `append-text` for `aui-state` `v1`

See the bridge guide for compatibility boundaries and caveats:
[External Store Runtime](/docs/runtimes/custom/external-store).

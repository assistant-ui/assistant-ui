---
title: Component Actions and Events
description: Deterministic component.invoke/component.emit routing for interactive component message parts.
---

import { Stage2ComponentParity } from "@/components/examples/stage2-component-parity";
import { DockedComposerComponentsDemo } from "@/components/examples/docked-composer-components";

<Callout type="warning">
  Interactive component actions/events are experimental and may change in
  future releases.
</Callout>

## Overview

Interactive assistant components can send signals back to your app when people
click, select, or submit inside a message UI.

There are two signal types:

- `invoke`: request/response
- `emit`: fire-and-forget event

## What this enables

- "Approve", "Retry", or "Refresh" actions directly in assistant messages.
- Event tracking from message UI interactions (tab changes, selections).
- Deterministic success/error behavior for user-triggered actions.

## When to use this

Use this when your assistant responses include interactive components, not just
text.

For standard runtime setup, start with
[AI SDK v6 Runtime](/docs/runtimes/ai-sdk/v6).

## invoke vs emit

- `invoke`:
  Use when the UI needs a result (`success`/`error`) before it can continue.
- `emit`:
  Use when the UI is just notifying your app that something happened.

## Conversation-Driven Docked UI Demo

This demo shows a thread where component cards stay docked above the composer.
As you chat, those cards evolve in real time.

<DockedComposerComponentsDemo />

### Try this

1. Click one of the suggestion chips.
2. Watch priority/deadline/status update in the docked cards.
3. Type your own goal, deadline, risk, or next step to drive new state changes.

## Contract Replay Demo

This second demo focuses on the low-level invoke/emit contract behavior.

The demo below replays a fixture sequence:

1. invoke `refresh` and receive deterministic `ack`
2. invoke `fail` and receive deterministic `reject`
3. emit `selected` as fire-and-forget

<Stage2ComponentParity />

### What to look for in the demo

1. `refresh` resolves (`ack`) and updates the success field.
2. `fail` rejects and surfaces an error message.
3. `selected` emits an event without blocking UI.

This mirrors common product flows like approvals, retries, and tab/filter
changes inside assistant-rendered UI.

## Runtime Wiring

For AI SDK runtimes, bind handlers directly on `useAISDKRuntime`:

```tsx
const runtime = useAISDKRuntime(chat, {
  onComponentInvoke: async ({ messageId, instanceId, action, payload }) => {
    // execute action, then return ack payload
    return { ok: true, messageId, instanceId, action, payload };
  },
  onComponentEmit: ({ messageId, instanceId, event, payload }) => {
    // fire-and-forget event routing
    console.log({ messageId, instanceId, event, payload });
  },
});
```

## Error behavior

- `invoke` can resolve or reject. Your UI should handle both.
- `emit` should not block UI, even if your event handler fails.
